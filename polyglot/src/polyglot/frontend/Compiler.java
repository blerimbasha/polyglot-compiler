package jltools.frontend;

import jltools.ast.*;
import jltools.parse.*;
import jltools.lex.*;
import jltools.types.*;
import jltools.util.*;
import jltools.visit.*;
import jltools.main.Options;
import jltools.main.Main;

import java.io.*;
import java.util.*;

/**
 * This is the main entry point for the compiler. It contains a work list that
 * contains entries for all classes that must be compiled (or otherwise worked
 * on).
 */
public class Compiler
{
    /** 
     * Marks major changes in the output format of the files produced by the
     * compiler. Files produced be different major versions are considered
     * incompatible and will not be used as source of class information.
     */
    public static int VERSION_MAJOR = 0;
    
    /** 
     * Indicates a change in the compiler that does not affect the output
     * format.  Source files will be prefered over class files build by
     * compilers with different minor versions, but if no source file is
     * available, then the class file will be used.
     */
    public static int VERSION_MINOR = 3;

    /**
     * Denote minor changes and bugfixes to the compiler. Class files compiled
     * with versions of the compiler that only differ in patchlevel (from the
     * current instantiation) will always be preferred over source files
     * (unless the source files have newer modification dates).
     */
    public static int VERSION_PATCHLEVEL = 0;

    /* Global options and state. */

    /** Command-line options */
    private Options options;

    /**
     * The system class resolver.  The class resolver contains a map from class
     * names to ClassTypes.  A Job looks up classes first in its import table
     * and then in the system resolver.  The system resolver first tries to
     * find the class in parsed class resolver
     */
    private CachingClassResolver systemResolver;

    /**
     * The parsed class resolver.  This resolver contains classes parsed from
     * source files.
     */
    private TableClassResolver parsedResolver;

    /**
     * The loaded class resolver.  This resolver automatically loads types from
     * class files and from source files not mentioned on the command line.
     */
    private LoadedClassResolver loadedResolver;

    /** The type system. */
    protected TypeSystem type_system;
    
    /** The extension factory creates node extension objects. */
    protected ExtensionFactory extension_factory;

    /**
     * The source loader is responsible for loading source files from the
     * source path.
     */
    protected SourceLoader source_loader;

    /**
     * The target factory is responsible for naming and opening output files
     * given a package name and a class or source file name.
     */
    protected TargetFactory target_factory;

    /**
     * The scheduler returns a list of passes needed to process compile a
     * source file.
     */
    protected Scheduler scheduler;

    /** The error queue handles outputting error messages. */
    ErrorQueue eq;

    /** The work list */
    List workList;

    /** A map from sources to jobs on the work list */
    Map inWorkList;

    /** A work list used for class cleaning. */
    LinkedList cleanWorkList;

    /**
     * The output files generated by the compiler.  This is used to to call the
     * post-compiler (e.g., javac).
     */
    private Collection outputFiles = new HashSet();

    /**
     * Initialize the compiler. 
     *
     * @param options Contains jltools options
     */
    public Compiler(Options options_) {
	options = options_;

	// These must be done after the extension is initialized.
	source_loader = options.extension.sourceLoader();
	target_factory = options.extension.targetFactory();
	scheduler = options.extension.scheduler();

	type_system = options.extension.typeSystem();
	extension_factory = options.extension.extensionFactory();

	eq = new ErrorQueue(System.err);
     
	// Create the compiler and set up the resolvers.
	CompoundClassResolver compoundResolver = new CompoundClassResolver();
	    
	parsedResolver = new TableClassResolver();
	compoundResolver.addClassResolver(parsedResolver);
	
	loadedResolver = new LoadedClassResolver(this, type_system);
	compoundResolver.addClassResolver(loadedResolver);

	systemResolver = new CachingClassResolver(compoundResolver);

	/* Other setup. */
	workList = new LinkedList();
	inWorkList = new HashMap();

	cleanWorkList = new LinkedList();

	// This must be done last.
	options.extension.initCompiler(this);
    }

    public LinkedList cleanWorkList() {
	return cleanWorkList;
    }

    /** Return a set of output filenames resulting from a compilation. */
    public Collection outputFiles() {
	return outputFiles;
    }

    /** Compile a source file until the types in the source file are cleaned. */
    public boolean cleanSource(Source source) throws IOException {
	return compileSource(source, Scheduler.CLEAN);
    }

    /** Compile a source file completely. */
    public boolean compileSource(Source source) throws IOException {
	return compileSource(source, Scheduler.TRANSLATE);
    }

    /** Compile a source file up to and including a given pass. */
    public boolean compileSource(Source source, PassID goal)
	throws IOException {
	Job job = addJob(source);

	boolean okay = compile(job, goal);

	if (hasErrors(job)) {
	    return false;
	}

	return okay;
    }

    /** Compile the source file for a given class up to a given pass. */
    public boolean compileClass(String className, PassID goal)
	throws IOException {
	Source source = source_loader.classSource(className);
	return compileSource(source, goal);
    }

    /** Compile the source file for a given class to completion. */
    public boolean compileClass(String className) throws IOException {
	return compileClass(className, Scheduler.TRANSLATE);
    }

    /**
     * Compile all the files listed in the set of strings <code>source</code>.
     * Return true on success. The method <code>outputFiles</code> can be
     * used to obtain the output of the compilation.  This is the main entry
     * point for the compiler, called from main().
     */
    public boolean compile(Collection sources) {
	try {
	    for (Iterator i = sources.iterator(); i.hasNext(); ) {
		String sourceName = (String) i.next();
		Source source = source_loader.fileSource(sourceName);
		addJob(source);
	    }

	    boolean okay = finish(Scheduler.TRANSLATE);

	    if (okay) {
		// Just check that we compiled everything.

		for (Iterator i = workList.iterator(); i.hasNext(); ) {
		    Job job = (Job) i.next();

		    if (job.hasCompleted(Scheduler.TRANSLATE)) {
			i.remove();
			inWorkList.remove(job);
		    }
		}

		if (! workList.isEmpty()) {
		    throw new InternalCompilerError(
			"Some sources were not compiled: " + workList);
		}
	    }

	    eq.flush();

	    return okay;
	}
	catch (FileNotFoundException e) {
	    eq.flush();
	    System.err.println(options.extension.compilerName() +
			       ": cannot find source file " + e.getMessage());
	    return false;
	}
	catch (IOException e) {
	    eq.flush();
	    System.err.println(options.extension.compilerName() + ": " +
			       e.getMessage());
	    return false;
	}
	catch (ErrorLimitError e) {
	    eq.flush();
	    return false;
	}
    }

    /** Add a job for a given source to the work list. */
    Job addJob(Source source) {
	Job job = (Job) inWorkList.get(source);

	if (job == null) {
	    job = options.extension.createJob(source);
	    workList.add(job);
	    inWorkList.put(source, job);
	}

	return job;
    }
      
    /** Should fully qualified class names be used in the output? */
    public boolean useFullyQualifiedNames() {
	return options.fully_qualified_names;
    }

    /** Compile all jobs in the work list up to a given pass. */
    public boolean finish(PassID goal) throws IOException {
	boolean okay = true;

	// New jobs are only added to the end of the work list.
	for (int i = 0; i < workList.size(); i++) {
	    Job job = (Job) workList.get(i);

	    okay &= compile(job, goal);

	    if (hasErrors(job)) {
		okay = false;
	    }
	}

	return okay;
    }

    /** Get the compiler's source loader */
    public SourceLoader sourceLoader() {
	return source_loader;
    }

    /** Get the compiler's target factory */
    public TargetFactory targetFactory() {
	return target_factory;
    }

    /** Get the compiler's node extension factory */
    public ExtensionFactory extensionFactory() {
	return extension_factory;
    }

    /** Get the compiler's type system */
    public TypeSystem typeSystem() {
	return type_system;
    }

    /** Get information about the language extension being compiled. */
    public ExtensionInfo extensionInfo() {
	return options.extension;
    }

    /** Get the compiler's system resolver */
    public ClassResolver systemResolver() {
	return systemResolver;
    }

    /** Get the compiler's parsed-file resolver */
    public TableClassResolver parsedResolver() {
	return parsedResolver;
    }

    /** Maximum number of characters on each line of output */
    public int outputWidth() {
	return options.output_width;
    }

    /** Should class info be serialized into the output? */
    public boolean serializeClassInfo() {
	return options.serialize_type_info;
    }

    /** Get the compiler's error queue. */
    public ErrorQueue errorQueue() {
	return eq;
    }

    /**
     * Compile a job up to a given pass.  This method runs the passes returned
     * by the scheduler for this job.
     *
     * @param job The job information (including a target) to be compiled.
     * @param goal The required stage to which this job should be taken
     * @return <code>true</code> iff <code>job</code> has completed stage
     *  <code>goal</code> without errors.
     */
    protected boolean compile(Job job, PassID goal) throws IOException {
	report(1, "Compiling " + job + " to " + goal);

	if (job.hasCompleted(goal)) {
	    return true;
	}

	try {
	    boolean okay = true;

	    Iterator i = scheduler.passes(job, goal);
	    
	    while (i.hasNext() && okay) {
		PassID pass = (PassID) i.next();

		report(2, job.source().toString() + ": running pass " + pass);

		Pass p = scheduler.getPass(job, pass);

		okay &= p.run();

		report(2, job.source().toString() + ": finished " + pass +
		    " -- " + (okay ? "ok" : "failed"));

		job.complete(pass);

		if (hasErrors(job)) {
		    return false;
		}
	    }

	    return okay;
	}
	catch (IOException e) {
	    eq.enqueue(ErrorInfo.IO_ERROR,
		       "Encountered an I/O error while compiling: " +
		       e.getMessage());
	    return false;
	}
	catch (RuntimeException e) {
	    CodeWriter cw = new CodeWriter(new UnicodeWriter(
					   new FileWriter( "ast.dump")),
					   options.output_width);
	    job.dump(cw);
	    throw e;
	}
	catch (Error e) {
	    CodeWriter cw = new CodeWriter(new UnicodeWriter(
					   new FileWriter( "ast.dump")),
					   options.output_width);
	    job.dump(cw);
	    throw e;
	}
    }

    /** Check if the job's error queue is empty. */
    protected boolean hasErrors(Job job) throws IOException {
	if (eq.hasErrors()) {
	    try {
		CodeWriter cw = new CodeWriter(new UnicodeWriter(
		  new FileWriter("onError.dump")), 76);
		job.dump(cw);
	    }
	    catch (IOException exn) {
	    }

	    return true;
	}

	return false;
    }

    static Collection topics = new ArrayList(1);

    static {
	topics.add("frontend");
    }

    public static void report(int level, String msg) {
	Main.report(topics, level, msg);
    }

    static {
      // FIXME: if we get an io error (due to too many files open, for example)
      // it will throw an exception. but, we won't be able to do anything with
      // it since the exception handlers will want to load
      // jltools.util.CodeWriter and jltools.util.ErrorInfo to print and
      // enqueue the error; but the classes must be in memory since the io
      // can't open any files; thus, we force the classloader to load the class
      // file.
      try {
	ClassLoader loader = jltools.frontend.Compiler.class.getClassLoader();
	loader.loadClass("jltools.util.CodeWriter");
	loader.loadClass("jltools.util.ErrorInfo");
      }
      catch (ClassNotFoundException e) {
	throw new InternalCompilerError(e.getMessage());
      }
    }
}
