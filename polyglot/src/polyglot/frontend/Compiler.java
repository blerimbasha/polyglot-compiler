package jltools.frontend;

import jltools.ast.*;
import jltools.types.*;
import jltools.types.reflect.*;
import jltools.util.*;
import jltools.visit.*;
import jltools.main.Options;
import jltools.main.Report;

import java.io.*;
import java.util.*;

/**
 * This is the main entry point for the compiler. It contains a work list that
 * contains entries for all classes that must be compiled (or otherwise worked
 * on).
 */
public class Compiler
{
    /** Command-line options */
    private Options options;

    /** The error queue handles outputting error messages. */
    ErrorQueue eq;

    /** A map from sources to source jobs. */
    Map jobs;

    /** A list of all the source jobs. */
    LinkedList worklist;

    /** The currently running job, or null. */
    Job currentJob;

    /** Class file loader.  There should be only one of these so we can cache
     * across type systems. */
    ClassFileLoader loader;

    /**
     * The output files generated by the compiler.  This is used to to call the
     * post-compiler (e.g., javac).
     */
    private Collection outputFiles = new HashSet();

    /**
     * Initialize the compiler.
     *
     * @param options Contains jltools options
     */
    public Compiler(Options options_) {
	options = options_;

	eq = new StdErrorQueue(System.err, options.error_count,
                               options.extension.compilerName());

	/* Other setup. */
	jobs = new HashMap();
        worklist = new LinkedList();
        currentJob = null;
        loader = new ClassFileLoader();

	// This must be done last.
	options.extension.initCompiler(this);
    }

    /** Return a set of output filenames resulting from a compilation. */
    public Collection outputFiles() {
	return outputFiles;
    }

    /**
     * Compile a source file until the types in the source file are
     * constructed.
     */
    public boolean readSource(ExtensionInfo sourceExt, Source source) throws IOException {
	Job job = jobForSource(sourceExt, source);

        if (sourceExt != sourceExtension()) {
            // Abort now is the source file is for a language other than the
            // source language.  We cannot support this now because each
            // extension has its own list of passes and the barrier passes
            // might not match up.
            throw new InternalCompilerError("Loading source files for " +
                                            "multiple languages is not " +
                                            "supported.");
        }

        // Run the new job up to its owner's (the current job's) barrier.
        Pass.ID barrier;
        
        if (currentJob != null) {
            if (currentJob.lastBarrier() == null) {
                throw new InternalCompilerError("Job which has not reached a " +
                                                "barrier cannot read another " +
                                                "source file.");
            }

            barrier = currentJob.lastBarrier().id();
        }
        else {
            barrier = Pass.BUILD_TYPES_ALL;
        }

        return runToPass(job, barrier);
    }

    /** Get a job for the source. */
    public SourceJob jobForSource(ExtensionInfo sourceExt, Source source) {
	SourceJob job = (SourceJob) jobs.get(source);

	if (job == null) {
            job = sourceExt.createJob(currentJob, source);
	    jobs.put(source, job);
            worklist.add(job);
	}

	return job;
    }

    /**
     * Compile all the files listed in the set of strings <code>source</code>.
     * Return true on success. The method <code>outputFiles</code> can be
     * used to obtain the output of the compilation.  This is the main entry
     * point for the compiler, called from main().
     */
    public boolean compile(Collection sources) {
	boolean okay = false;

	try {
	    try {
                SourceLoader source_loader = sourceExtension().sourceLoader();

		for (Iterator i = sources.iterator(); i.hasNext(); ) {
		    String sourceName = (String) i.next();
		    Source source = source_loader.fileSource(sourceName);
		    Job u = jobForSource(sourceExtension(), source);
		}

		okay = finish();
	    }
	    catch (FileNotFoundException e) {
		eq.enqueue(ErrorInfo.IO_ERROR,
		    "Cannot find source file \"" + e.getMessage() + "\".");
	    }
	    catch (IOException e) {
		eq.enqueue(ErrorInfo.IO_ERROR, e.getMessage());
	    }
	    catch (InternalCompilerError e) {
		e.printStackTrace();
		eq.enqueue(ErrorInfo.INTERNAL_ERROR, e.message(), e.position());
	    }
	}
	catch (ErrorLimitError e) {
	}

	eq.flush();
	return okay;
    }

    /** Run a job until the <code>goal</code> pass completes. */
    public boolean runToPass(Job job, Pass.ID id) {
	report(1, "Running " + job + " to pass named " + id);

        if (job.completed(id)) {
            return true;
        }

        Pass pass = job.passByID(id);

        return runToPass(job, pass);
    }

    public boolean runToPass(Job job, Pass goal) {
	report(1, "Running " + job + " to pass " + goal);

        boolean okay = job.status();

	while (! job.pendingPasses().isEmpty()) {
	    Pass pass = (Pass) job.pendingPasses().get(0);

	    report(2, "Trying to run pass " + pass);

            if (job.isRunning()) {
                // We're currently running.  We can't reach the goal.
                throw new InternalCompilerError(job + " cannot reach pass " +
                                                pass);
            }

            long start_time = System.currentTimeMillis();

            if (okay) {
                Job oldCurrentJob = currentJob;
                currentJob = job;

                job.setIsRunning(true);
                okay &= pass.run();
                job.setIsRunning(false);

                currentJob = oldCurrentJob;
            }

            job.finishPass(pass, okay);

            report(2, "Finished " + pass + " status=" + str(okay));
            reportTime(1, "Finished " + pass + " status=" + str(okay) +
                    " time=" + (System.currentTimeMillis() - start_time));

            if (pass == goal) {
                break;
            }
        }

	report(1, "Pass " + goal + " " + str(okay));

	return okay;
    }

    private static String str(boolean okay) {
        if (okay) {
            return "done";
        }
        else {
            return "failed";
        }
    }

    public boolean runNextPass(Job job) {
	if (! job.pendingPasses().isEmpty()) {
	    Pass pass = (Pass) job.pendingPasses().get(0);
	    return runToPass(job, pass);
	}

	return true;
    }

    public boolean runAllPasses(Job job) {
      	List passes = job.pendingPasses();

	if (! passes.isEmpty()) {
	    // Run to the last pass.
	    Pass pass = (Pass) passes.get(passes.size()-1);
	    return runToPass(job, pass);
	}

	return true;
    }

    /** Run all jobs in the source work group to completion. */
    protected boolean finish() {
	boolean okay = true;

        // Run the jobs breadth-first rather than depth first to ensure
        // inter-dependent jobs in the worklist are kept in sync.
        while (okay && ! worklist.isEmpty()) {
            SourceJob job = (SourceJob) worklist.removeFirst();
            report(1, "Running job " + job);
            okay &= runNextPass(job);

            if (! job.completed()) {
                worklist.add(job);
            }
        }

	report(1, "Finished all passes -- " + (okay ? "okay" : "failed"));

	return okay;
    }

    public ClassFileLoader loader() {
        return this.loader;
    }

    /** Should fully qualified class names be used in the output? */
    public boolean useFullyQualifiedNames() {
	return options.fully_qualified_names;
    }

    /** Get information about the language extension being compiled. */
    public ExtensionInfo sourceExtension() {
	return options.extension;
    }

    /** Maximum number of characters on each line of output */
    public int outputWidth() {
	return options.output_width;
    }

    /** Should class info be serialized into the output? */
    public boolean serializeClassInfo() {
	return options.serialize_type_info;
    }

    /** Should the AST be dumped? */
    public boolean dumpAst() {
        return options.dump_ast;
    }

    /** Get the compiler's error queue. */
    public ErrorQueue errorQueue() {
	return eq;
    }

    private static Collection topics = new ArrayList(1);
    private static Collection timeTopics = new ArrayList(1);

    static {
	topics.add("frontend");
	timeTopics.add("time");
    }

    /** Debug reporting for the frontend. */
    public static void report(int level, String msg) {
	Report.report(topics, level, msg);
    }

    /** Reports the time taken by every pass. */
    public static void reportTime(int level, String msg) {
	Report.report(timeTopics, level, msg);
    }

    static {
      // FIXME: if we get an io error (due to too many files open, for example)
      // it will throw an exception. but, we won't be able to do anything with
      // it since the exception handlers will want to load
      // jltools.util.CodeWriter and jltools.util.ErrorInfo to print and
      // enqueue the error; but the classes must be in memory since the io
      // can't open any files; thus, we force the classloader to load the class
      // file.
      try {
	ClassLoader loader = Compiler.class.getClassLoader();
	// loader.loadClass("jltools.util.CodeWriter");
	// loader.loadClass("jltools.util.ErrorInfo");
	loader.loadClass("jltools.util.StdErrorQueue");
      }
      catch (ClassNotFoundException e) {
	throw new InternalCompilerError(e.getMessage());
      }
    }
}
