<html>
<head>
<title>JLgen documentation</title>
</head>

<body bgcolor="white">
<h1>JLgen : a parser generator for extensible grammars</h1>

JLgen is a parser generator for extensible grammars, based on the
<a href="http://www.cs.princeton.edu/~appel/modern/java/CUP/">CUP</a>
parser generator. It provides the 
ability to extend an existing base language grammar written in CUP or
JLgen with localized, easily maintained changes.

<h2>Distribution of JLgen</h2>
JLgen was designed and written by Michael Brukman and Andrew C. Myers
at Cornell University. It is part of the
<a href="http://www.cs.cornell.edu/Projects/jltools">
JLtools Java extensible compiler
toolkit</a>.
It can be also be obtained
<a href="http://www.cs.cornell.edu/Projects/jltools/jlgen">
separately</a>.
Questions about JLgen should be directed to Andrew Myers
(<a href="mailto:myers@cs.cornell.edu">myers@cs.cornell.edu)</a>).

<a name="usage"><h2>JLgen syntax</h2></a>
The JLgen grammar syntax extends that of CUP with several new declarations:
<ol>
  <li>The first line of a JLgen specification is <ul><tt><b>include</b>
    &quot;</tt><i>filename</i><tt>&quot;</tt></ul> where <i>filename</i>
    is a relative path to the inherited specification.  A JLgen spec can
    include a CUP spec or another JLgen spec. It is an error for the
    chain of included files to contain a cycle.
  <li>A JLgen grammar specification can modify the inherited grammar
	using the following commands:
  <ul>
    <li><tt><b>precedence</b></tt> [ <b>left</b> | <b>right</b> |
	<b>nonassoc</b> ] <i>tokenlist</i><b>;</b><br> is the syntax
	for specifying new precedence rules, which is exactly as they
	are specified in CUP. Specification of new precedence rules
	in a JLgen specification replaces the precedence rules in the
	inherited grammar with these.

    <li><tt><b>precedence;</b></tt><br> deletes all precedence rules
	from the inherited grammar, and is mutually exclusive with
	the syntax above: to add new precedence rules use the above
	syntax, use of this statement will only remove precedence
	rules.

    <li><tt><b>drop {</b></tt> <i>symbol</i> <tt><b>}</b></tt><br>
      where <i>symbol</i> is an <u>inherited</u> terminal or
      nonterminal.<br> The specified <i>symbol</i> is removed from grammar, and
      if a nonterminal, all productions where it is on the
      <b>left-hand side</b> are also eliminated. It is an error to drop
      a non-terminal and not drop productions where it is mentioned on the
      <b>right-hand side</b>.
      
    <li><tt><b>drop {</b></tt> <i>S</i> <tt><b>::=</b></tt> &lt;
      <i>productions</i>&gt; <tt><b>; }</b></tt><br> where <i>S</i>
      is an <u>inherited</u> nonterminal, and <i>productions</i>
      are inherited productions. The specified productions are not
      inherited from the base grammar. The nonterminal remains in the
      grammar, even if ALL of its productions are dropped in this way;
      <tt><b>drop {</b> <i>S</i> <b>}</b></tt> must be used if the
      nonterminal is to be eliminated.
      
    <li><tt><b>override</b></tt> <i>S</i> <tt><b>::=</b></tt> &lt;
      <i>productions</i>&gt; <tt><b>;</b></tt><br>
      The specified productions replace productions of <i>S</i>.
      
    <li><tt><b>extend</b></tt> <i>S</i> <tt><b>::=</b></tt> &lt;
      <i>productions</i>&gt; <tt><b>;</b></tt><br>
      Specified productions are added to the nonterminal <i>S</i>.
      
    <li><tt><b>transfer</b></tt> <i>S</i> <tt><b>to</b></tt>
      <i>A<sub>1</sub></i> { <i>rhs</i><sub>1</sub> } <tt><b>to</b></tt>
      <i>A<sub>n</sub></i> { <i>rhs<sub>n</sub></i> }<br> where
      <i>rhs<sub>i</sub></i> is one or more right-hand sides
      of productions of <i>S</i>. Each of the nonterminals
      <i>A<sub>i</sub></i> is extended with productions as specified,
      and the transferred productions are not inherited
      by <i>S</i>, so a single production can be transferred to
      multiple nonterminals. Note that <i>S</i> may be one of the
      <i>A<sub>i</sub></i>, which has the effect of retaining the
      productions in <i>S</i>.

    <li>New terminals, nonterminals, and productions can be defined
    as in CUP and extend the base grammar.

  </ul>
</ol>


The syntax for invocation of JLgen is simply<br>
<ul><tt>jlgen</tt> &lt;<i>grammar file</i>&gt;</ul>
for either a standard CUP file or for a JLgen-based grammar
inheritance file.<p>

The inherited base grammar file is searched for relative to the location
of the JLgen source file.

<a name="semantics"><h2>Semantics of JLgen</h2></a>

The order of specification of commands is not important. The resulting
productions for any nonterminal N is as follows:
<ul>N' = N - drop(N) - transferL(N) + override(N) + transferR(N) +
extend(N) + newProductions(N)</ul><br>

The resulting available set of terminals is simply:
<ul>T' = T - drop(T) + newTerminals</ul>
where T is the set of terminals from base grammar, drop(T) is the
set of dropped terminals using the <b>drop</b> command, <b>newTerminals</b>
are terminals defined using CUP syntax. The resulting set of nonterminals
is similar.<br>

For precedence rules:
<ul>P' = {}</ul>
if "<tt><b>precedence;</b></tt>" is specified by the JLgen grammar, thus 
not inheriting any precedence rules from the base grammar, or
<ul>P' = P<sub>new</sub></ul>
where any newly defined precedence rules override any inherited precedence
rules from the base grammar.

</body>
</html>
