This document describes the major changes made to the Polyglot framework
for version 2.0 and how to upgrade extensions written for Polyglot 1.3.

The pass scheduling code was rewritten for Polyglot 2.0.  The goal was
to simplify the disambiguation passes, reduce the need for barrier
passes, and clean up the invariants assumed by the passes.

As an example, the Jx extension to Polyglot 1.3 had the following
disambiguation passes:

        create packages
        barrier
        disambiguate packages
        barrier
        type builder
        barrier
        disambiguate supertypes
        add dummy fields
        barrier
        disambiguate member signatures
        remove dummy fields 
        barrier
        disambiguate method bodies
        add members
        type check
        ...

The new schedule has the following passes:

        type builder
        barrier
        disambiguate
        type check
        ...
        
The changes to the scheduler are not backward compatible and some porting
effort is required.  Porting small extensions (e.g., PAO) takes a few minutes.
Porting Coffer took a few hours.  Larger extensions (e.g., Jif, Jx) may take a
few days or a week.

Changes
-------

The new scheduler works by attempting to satisfy _goals_.
Examples of goals are:

Parsed(Job)
        - Satisfied if the job's source file has been parsed
MembersAdded(ClassType)
        - Satisfied if members have been added to the class's type object
SupertypesResolved(ClassType)
        - Satisfied if the class's supertypes have been disambiguated
SignaturesResolved(ClassType)
        - Satisfied if member signatures of the class have been disambiguated
VisitorGoal(Job, Visitor) -
        - Satisfied if visitor has been run over job's AST
CodeGenerated(Job)
        - Satisfied if code has been generated from the job's AST


A goal may be dependent on other goals.

Goals can be satisfied by running passes.  Most passes just run a visitor over
the AST.  If no errors are encountered when running a pass, the pass is said to
succeed.  Even if a pass succeeds, the goal may not be satisfied because
running the pass may have caused the goal to become dependent upon another
goal, which is not yet satisfied.  For example, the disambiguation pass may
resolve a class name to a particular class C, but may not be able to lookup a
member of that class because the C's members have not yet been added to the
type object for C.  In this case, the disambiguation pass is rescheduled to run
after the members have been added.

There are two types of dependencies between goals: prerequisite and concurrent
dependencies.  If a goal has a prerequisite dependency, that dependency must be
satisfied before the goal is attempted.  The compiler will throw an
InternalCompilerError if there is a cycle of prerequisite dependencies.  If a
goal has a concurrent dependency, running a pass for the dependency may help
the dependent goal be satisfied.  Having a cycle of concurrent dependencies may
or may not cause the compiler to go into an infinite loop.  This situation is
detected at run time and the compiler aborts.

Concurrent dependencies should be avoided if possible.

Specific changes
----------------

Declarations (ClassDecl, MethodDecl, LocalDecl, Formal, etc)
should create corresponding TypeObjects exactly once, in the buildTypes pass.
Class members should also be added during buildTypes.  The new
TypeObjects
may be ambiguous (i.e., they may point to ambiguous TypeObjects).
Later passes should imperatively update the
TypeObjects to be unambiguous.

Since TypeObjects used in declarations should be updated imperatively,
setter methods are needed for new TypeObjects added by an extension.

    mi2 = mi.returnType(newType)

is now:

    mi2 = (MethodInstance) mi.copy();
    mi2.setReturnType(newType);

        -- should implement returnType(newType) to make porting easier

Declaration nodes should also implement isTypeChecked().
Non-declartion nodes with references to type objects
(e.g., Local, Field, Call) should implement isDisambiguated(). 

        -- other way round?

Pass.ID is no longer used.

ExtensionInfo.passes has been replaced by ExtensionInfo.compileGoalList

    old ExtensionInfo: 

      public List passes(Job job) {
          List passes = super.passes(job);
          beforePass(passes, Pass.PRE_OUTPUT_ALL,
                     new VisitorPass(CAST_REWRITE, job,
                                     new PaoBoxer(job, ts, nf)));
          return passes;
      }

    new ExtensionInfo:

      protected List compileGoalList(Job job) {
          List oldGoals = super.compileGoalList(job);
          ArrayList newGoals = new ArrayList(oldGoals.size() + 1);
          
          for (Iterator i = oldGoals.iterator(); i.hasNext(); ) {
              Goal g = (Goal) i.next();
              if (g instanceof Serialized) {
                  newGoals.add(new VisitorGoal(job,
                                               new PaoBoxer(job, ts, nf)));
              }
              newGoals.add(g);
          }
          
          return newGoals;
      }

    or:

      You can override the caller of compileGoalList, getCompileGoal.

spawn job is gone; just run visitors explicitly instead

HaltingVisitor is deprecated; use NodeVisitor.override to prune a visitor traversal

If new class member types are added, extend LazyClassInitializer
with init methods.  Extend LazyClassInitializer_c and
DeserializedLazyClassInitializer.
override TypeSystem_c.deserializedClassInitializer()
override TypeSystem_c.defaultClassInitializer()
override ParsedClassType_c.signaturesResolved()

Lexer_c takes a Source object, not the name of a source.
Adjust *.flex and ExtensionInfo accordingly.  It's probably easiest
just to copy over java.flex and reapply your changes.

    old ExtensionInfo:

      Lexer lexer = new Lexer_c(reader, source.name(), eq);

    new ExtensionInfo:

      Lexer lexer = new Lexer_c(reader, source, eq);

Optional: Use Position.compilerGenerated() rather than
Position.COMPILER_GENERATED




