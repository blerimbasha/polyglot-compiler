package polyglot.dispatch

import java.util._

import polyglot.ast._
import polyglot.frontend._
import polyglot.types._
import polyglot.types.Package
import polyglot.util.InternalCompilerError
import polyglot.util.Position
import polyglot.visit.ContextVisitor

import scala.collection.JavaConversions._

class ScalaTypeChecker(job: Job, ts: TypeSystem, nf: NodeFactory) {
    implicit def __at(s: String) = new At(s)
    class At(s: String) {
	def $(x: Node): (String,Position) = (s,x.position)
	def $(x: Position): (String,Position) = (s,x)
    }

    implicit def __orelse(x: Boolean) = new OrElse(x)
    class OrElse(x: Boolean) {
	def orelse(y: (String,Position)) =
            if (! x) throw new SemanticException(y._1, y._2)
	def orelse(y: String) =
            if (! x) throw new SemanticException(y)
    }

    // true orelse "bad" $ 1
    // false orelse "bad" $ 2
    
    implicit def wrapRef(r: Ref[A]) = new WrappedRef[A](r)

    class WrappedRef[A](r: Ref[A]) {
      def when(f: A => Unit) =
        r.addHandler(new Handler[A] { def handle(a: A) = f(a) } 
      def when(f: => Unit) =
        r.addHandler(new Handler[A] { def handle(a: A) = f } 
    }

    def when[A](r: Ref[A])(f: A => Unit) =
      r.addHandler(new Handler[A] { def handle(a: A) = f(a) } 

    override def accept(n: Node, args: Object*): Node = {
      if (n == null)
        null
      else
        n.checked
    }

    implicit def wrappedExp(e: Expr) = new WrappedExp(e)
    class WrappedExp(e: Expr) {
      def getType = e.`type`
      def setType(t: Type) = e.`type`(t)
    }

    def visit(n: Node_c, context: Context): Node = {
      println("missing node " + n + ": " + n.getClass.getName)
      acceptChildren(n).asInstanceOf[Node]
    }

    implicit def check(x: Boolean): OrElse = new OrElse(x)

    def error(s: String) = throw new SemanticException(s, pos)

    def visit(n: NewArray_c, context: Context): Unit = {
      for (e <- n.dims) 
        e.typeRef when t => {
          ts.isImplicitCastValid(t, ts.Int, context)
            orelse "Array dimension must be an integer." $ e
        }

      n.baseType.typeRef when t => {
        val arrayType = ts.arrayOf(t, n.dims.size + n.additionalDims)

        val init = n.init

        if (init != null) {
          typeCheckElements(context, arrayType, init)
        }

        n.setType(type)
      }
    }

    private def convert(e: Expr, t: Type): Expr {
      val s = e.getType
      if (! ts.isImplicitCastValid(s, t, context) &&
          ! ts.typeEquals(s, t, context) &&
          ! ts.numericConversionValid(t, e.constantValue, context)) {
        error "Cannot assign " + s + " to " + t + "."
      }
      else if (ts.isSubtype(s, t, context)) e
      else nf.Cast(t, e).type(t)
    }

    private def typeCheckElements(context: Context, typ: Type, init: ArrayInit): Unit = {
      // Check if we can assign each individual element.
      Type t = typ.toArray.base

      for (e <- init.elements) {
        e match {
          case e: ArrayInit =>
            e.typeRef when s => {
              s.isArray orelse "Cannot initialize " + t + " with " + s + "." $ e
              typeCheckElements(context, t, e)
            }
          case _ => {
            e.typeRef when s => {
              ! ts.isImplicitCastValid(s, t, context) &&
              ! ts.typeEquals(s, t, context) &&
              ! ts.numericConversionValid(t, e.constantValue, context)
              orelse "Cannot assign " + s + " to " + t + "." $ e
            }
          }
        }
      }
    }

    def visit(n: Assign_c, context: Context): Unit = {
      val left = n.left
      val op = n.operator
      val right = n.right

      left.typeRef when t => {
        right.typeRef when s => {
          op match {
            case x if x == Assign.ASSIGN => 
              n.setType(t)
            case x if x == Assign.ADD_ASSIGN && ts.typeEquals(t, ts.String, context) && ts.canCoerceToString(s, context)  =>
              n.setType(t)
            case x if x == Assign.ADD_ASSIGN if t.isNumeric && s.isNumeric =>
              n.setType(ts.promote(t, s))
            case x if x == Assign.SUB_ASSIGN if t.isNumeric && s.isNumeric =>
              n.setType(ts.promote(t, s))
            case x if x == Assign.MUL_ASSIGN if t.isNumeric && s.isNumeric =>
              n.setType(ts.promote(t, s))
            case x if x == Assign.DIV_ASSIGN if t.isNumeric && s.isNumeric =>
              n.setType(ts.promote(t, s))
            case x if x == Assign.MOD_ASSIGN if t.isNumeric && s.isNumeric =>
              n.setType(ts.promote(t, s))
            case x if x == Assign.BIT_AND_ASSIGN if t.isBoolean && s.isBoolean =>
              n.setType(ts.Boolean)
            case x if x == Assign.BIT_OR_ASSIGN if t.isBoolean && s.isBoolean =>
              n.setType(ts.Boolean)
            case x if x == Assign.BIT_XOR_ASSIGN if t.isBoolean && s.isBoolean =>
              n.setType(ts.Boolean)
            case x if x == Assign.BIT_AND_ASSIGN if t.isLongOrLess && s.isLongOrLess =>
              n.setType(ts.promote(t, s))
            case x if x == Assign.BIT_OR_ASSIGN if t.isLongOrLess && s.isLongOrLess =>
              n.setType(ts.promote(t, s))
            case x if x == Assign.BIT_XOR_ASSIGN if t.isLongOrLess && s.isLongOrLess =>
              n.setType(ts.promote(t, s))
            case x if x == Assign.SHL_ASSIGN if t.isLongOrLess && s.isLongOrLess =>
              n.setType(ts.promote(t))
            case x if x == Assign.SHR_ASSIGN if t.isLongOrLess && s.isLongOrLess =>
              n.setType(ts.promote(t))
            case x if x == Assign.USHR_ASSIGN if t.isLongOrLess && s.isLongOrLess =>
              n.setType(ts.promote(t))
            case x if x == Assign.ADD_ASSIGN => error "The " + op + " operator must have numeric or String operands."
            case x if x == Assign.SUB_ASSIGN => error "The " + op + " operator must have numeric operands."
            case x if x == Assign.MUL_ASSIGN => error "The " + op + " operator must have numeric operands."
            case x if x == Assign.DIV_ASSIGN => error "The " + op + " operator must have numeric operands."
            case x if x == Assign.MOD_ASSIGN => error "The " + op + " operator must have numeric operands."
            case x if x == Assign.BIT_AND_ASSIGN => error "The " + op + " operator must have integral or boolean operands."
            case x if x == Assign.BIT_OR_ASSIGN => error "The " + op + " operator must have integral or boolean operands."
            case x if x == Assign.BIT_XOR_ASSIGN => error "The " + op + " operator must have integral or boolean operands."
            case x if x == Assign.SHL_ASSIGN => error "The " + op + " operator must have integral operands."
            case x if x == Assign.SHR_ASSIGN => error "The " + op + " operator must have integral operands."
            case x if x == Assign.USHR_ASSIGN => error "The " + op + " operator must have integral operands."
            case _ => error "Unexpected assignment operator " + op + "."
          }
        }
      }
    }

    def visit(n: ArrayAccess_c, context: Context) = {
      n.array.typeRef when t => {
        t.isArray orelse
          ! "Subscript can only follow an array type." $ n

        n.setType(t.toArray.base)
      }

      n.index.typeRef when s => {
        ts.isImplicitCastValid(s, ts.Int, context)
        orelse "Array subscript must be an integer." $ n.index
      }
    }

    def visit(n: ArrayInit_c, context: Context) = {
      def collect(t: Type, xs: List[Expr]): Unit = xs match {
        case Nil => n.setType(ts.arrayOf(t))
        case y::ys => y.typeRef when s => {
          collect(ts.leastCommonAncestor(t, s, context), ys)
        }
      }

      if (n.elements.size == 0) {
        n.setType(ts.Null)
      }
      else {
        collect(ts.Null, n.elements.toList)
      }
    }

    def visit(n: Assert_c, context: Context) = {
      n.cond.typeRef when t => {
        t.isBoolean orelse
          "Condition of assert statement must have boolean type."
      }

      n.errorMessage.typeRef when t => {
        ! ts.typeEquals(t, ts.Void, context) orelse
          "Error message in assert statement must have a value."
      }
    }

    def visit(n: Binary_c, context: Context) = {
      n.left.typeRef when l => {
        n.right.typeRef when r => {
          n.operator match {
            case op if (op == Binary_c.GT || op == Binary_c.LT || op == Binary_c.GE || op == Binary_c.LE) => {
              l.isNumeric orelse "The " + op + " operator must have numeric operands, not type " + l + "."
              r.isNumeric orelse "The " + op + " operator must have numeric operands, not type " + r + "."
              n.setType(ts.Boolean)
            }
            case op if (op == Binary_c.EQ || op == Binary_c.NE) => {
              ts.isCastValid(l, r, context) || ts.isCastValid(r, l, context)
                orelse "The " + n.operator + " operator must have operands of similar type."
              n.setType(ts.Boolean)
            }
            case op if (op == Binary_c.COND_OR || op == Binary_c.COND_AND) => {
              l.isBoolean orelse "The " + op + " operator must have boolean operands, not type " + l + "."
              r.isBoolean orelse "The " + op + " operator must have boolean operands, not type " + r + "."
              n.setType(ts.Boolean)
            }
            case op if (op == Binary_c.ADD) if (ts.isSubtype(l, ts.String, context) || ts.isSubtype(r, ts.String, context)) => {
              ts.canCoerceToString(r, context)
                  orelse "Cannot coerce an expression " + "of type " + r + " to a String."
              ts.canCoerceToString(l, context)
                  orelse "Cannot coerce an expression " + "of type " + l + " to a String."

              n.setType(ts.String)
            }
            case op if (op == Binary_c.ADD) => {
              l.isNumeric orelse "The " + op + " operator must have numeric or String operands, not type " + l + "."
              r.isNumeric orelse "The " + op + " operator must have numeric or String operands, not type " + r + "."
              n.setType(ts.promote(l, r))
            }
            case op if (op == Binary_c.BIT_AND || op == Binary_c.BIT_OR || op == Binary_c.BIT_XOR) && (l.isBoolean && r.isBoolean) => {
              n.setType(ts.Boolean)
            }
            case op if (op == Binary_c.BIT_AND || op == Binary_c.BIT_OR || op == Binary_c.BIT_XOR) => {
              l.isLongOrLess orelse "The " + op + " operator must have numeric or boolean operands, not type " + l + "."
              r.isLongOrLess orelse "The " + op + " operator must have numeric or boolean operands, not type " + r + "."
              n.setType(ts.promote(l, r))
            }
            case op if (op == Binary_c.SUB || op == Binary_c.MUL || op == Binary_c.DIV || op == Binary_c.MOD) => {
              l.isNumeric orelse "The " + op + " operator must have numeric operands, not type " + l + "."
              r.isNumeric orelse "The " + op + " operator must have numeric operands, not type " + r + "."
              n.setType(ts.promote(l, r))
            }
            case op if (op == Binary_c.SHL || op == Binary_c.SHR || op == Binary_c.USHR) => {
              l.isLongOrLess orelse "The " + op + " operator must have integral operands, not type " + l + "."
              r.isLongOrLess orelse "The " + op + " operator must have integral operands, not type " + r + "."
              n.setType(ts.promote(l))
            }
          }
        }
      }
    }

    def visit(n: Unary_c, context: Context) = {
      n.expr.typeRef when t => {
        n.operator match {
          case op if (op == Unary_c.POST_INC || op == Unary_c.POST_DEC || op == Unary_c.PRE_INC || op == Unary_c.PRE_DEC) => {
            t.isNumeric orelse "Operand of " + n.operator + " operator must be numeric."
            n.expr match {
              case v: Variable => v.flags.isFinal orelse "Operand of " + n.operator + " operator must be a non-final variable."
              case v => error "Operand of " + n.operator + " operator must be a variable."
            }

            n.setType(t)
          }
          case op if (op == Unary_c.BIT_NOT) => {
            ts.isImplicitCastValid(t, ts.Long, context) orelse
              "Operand of " + op + " operator must be numeric."
            n.setType(ts.promote(t))
          }
          case op if (op == Unary_c.NEG || op == Unary_c.POS) => {
            t.isNumeric orelse
              "Operand of " + op + " operator must be numeric."
            n.setType(ts.promote(t))
          }
          case op if (op == Unary_c.NOT) => {
            t.isBoolean orelse
              "Operand of " + op + " operator must be boolean."
            n.setType(t)
          }
        }
      }
    }

    def visit(n: While_c, context: Context) = {
      n.cond.typeRef when t => {
        ts.isBoolean(t) orelse
          "Condition of while statement must have boolean type."
      }
    }

    def visit(n: Do_c, context: Context) = {
      n.cond.typeRef when t => {
        ts.isBoolean(t) orelse
          "Condition of do statement must have boolean type."
      }
    }

    def visit(n: If_c, context: Context) = {
      n.cond.typeRef when t => {
        ts.isBoolean(t) orelse
          "Condition of if statement must have boolean type."
      }
    }

    def visit(n: Switch_c, context: Context) = {
      n.index.typeRef when t => {
        ts.isIntOrLess(t) orelse
          "Switch index must be an integer."
      }

      var labels = Set[Object]

      // Check for duplicate labels.
      for (e <- n.elements) {
        val (key,str) = e match {
          case c: Case if c.isDefault => {
            ("default", "default")
          }
          case c: Case if c.expr.isConstant => {
            (c.value, c.expr.toString + " (" + c.value + ")")
          }
          case _ => (null, null)
        }

        labels contains key orelse "Duplicate case label: " + str + "."
        labels += key
      }
    }

    def visit(n: Call_c, context: Context) = {
      def collect(es: List[Expr], ts: List[Type]): Unit = es match {
        case Nil =>
          if (n.target == null) typeCheckNullTarget(n, context, ts)
          else {
            n.target.typeRef when t => {
              val mi = ts.findMethod(t, ts.MethodMatcher(t, n.name.id, ts, c))

              // If the target is super, but the method is abstract, then
              // complain.
              n.target match {
                case tgt: Special => 
                  ! (tgt.kind == Special.SUPER && mi.flags.isAbstract)
                    orelse "Cannot call an abstract method of the super class"
                case tgt: TypeNode =>
                  // This call is in a static context if and only if the target
                  // (possibly implicit) is a type node.
                  mi.flags.isStatic
                    orelse "Cannot call non-static method " + n.name.id + " of " + t + " in static context."
                case _ =>
              }

              mi.returnTypeRef when rt => {
                n.setType(rt)
              }

              n.methodInstance(mi)

              // If the target is implicit. Check that the
              // method found in the target type is the
              // same as the method found in the context.
              if (n.isTargetImplicit) {
                val mi2 = context.findMethod(ts.MethodMatcher(null, n.name.id, mi.formalTypes, context))
                ts.isSameMethod(mi2, mi)
              }
            }
          }
        case e::es => e.typeRef when t => {
          collect(es, ts ::: t :: Nil)
        }
      }
    }

    private def typeCheckNullTarget(n: Call_c, context: Context, argTypes: List[Type]) = {
	// the target is null, and thus implicit
	// let's find the target, using the context, and
	// set the target appropriately, and then type check
	// the result
	val mi = context.findMethod(ts.MethodMatcher(null, n.name.id, argTypes, context))

        val r =
          if (mi.flags.isStatic) {
	    val container = n.findContainer(ts, mi)            
	    nf.CanonicalTypeNode(n.position.startOf, container).typeRef(Types.ref(container))
          }
          else {
	    // The method is non-static, so we must prepend with "this", but we
	    // need to determine if the "this" should be qualified.  Get the
	    // enclosing class which brought the method into scope.  This is
	    // different from mi.container.  mi.container returns a super type
	    // of the class we want.
	    val scope = context.findMethodScope(n.name.id)

	    if (! ts.typeEquals(scope, context.currentClass, context)) {
              nf.This(n.position.startOf, nf.CanonicalTypeNode(n.position.startOf, scope))
	    }
	    else {
              nf.This(n.position.startOf)
	    }
          }

        r = copyAttributesFrom(r, n)
	r = setContext(r, context)
	r = accept(r)

        mi.returnTypeRef when rt => {
          n.setType(rt)
        }

	// we call computeTypes on the receiver too.
        n.checked(n.targetImplicit(true).target(r))
        n.methodInstance(mi)
    }

    def visit(n: Cast_c, context: Context) = {
      n.expr.typeRef when t => {
        n.castType.typeRef when s => {
          ts.isCastValid(t, s, context) orelse
          "Cannot cast the expression of type \"" + t + "\" to type \"" + s + "\"."
          n.setType(s)
        }
      }
    }

    def visit(n: For_c, context: Context) = {
      // Check that all initializers have the same type.
      // This should be enforced by the parser since one can only write
      // T x1=e1, x2=e2, ..., but check again here, just to be sure.
      var t = null

      n.inits.toList match {
        case Nil =>
        case x::xs =>
          x.typ.typeRef when xt => {
            for (s <- xs) {
              s match {
                case d: LocalDecl => {
                  d.typ.typeRef when dt => {
                    ts.typeEquals(xt, dt, context) orelse
                      "Local variable declarations in a for loop initializer must all be the same type, in this case " + xt + ", not " + dt + "."
                  }
                }
              }
            }
          }
      }

      n.cond.typeRef when t => {
        ts.isImplicitCastValid(t, ts.Boolean, context) orelse
          "The condition of a for statement must have boolean type."
      }
    }

    def visit(n: LocalDecl_c, context: Context) = {
	// Check if the variable is multiply defined.
	// we do it in type check enter, instead of type check since
	// we add the declaration before we enter the scope of the
	// initializer.
	Context c = context

	LocalInstance outerLocal = null

	try {
	    outerLocal = c.findLocal(n.localDef.name)
	}
	catch (SemanticException e) {
	    // not found, so not multiply defined
	}

	if (outerLocal != null && c.isLocal(n.localDef.name)) {
	    throw new SemanticException(
	                                "Local variable \"" + n.name + "\" multiply defined.  " + "Previous definition at " + outerLocal.position + ".",
	                                n.position)
	}
	n = (LocalDecl_c) acceptChildren(n)

	try {
	    ts.checkLocalFlags(n.flags.flags)
	}
	catch (SemanticException e) {
	    throw new SemanticException(e.getMessage, n.position)
	}

	if (n.init != null) {
	    if (n.init instanceof ArrayInit) {
		typeCheckElements(context, n.type.type, (ArrayInit) n.init)
	    }
	    else {
		if (!ts.isImplicitCastValid(n.init.type, n.type.type, context) && !ts.typeEquals(n.init.type, n.type.type, context)
			&& !ts.numericConversionValid(n.type.type, n.init.constantValue, context)) {
		    throw new SemanticException("The type of the variable " + "initializer \"" + n.init.type + "\" does not match that of "
		                                + "the declaration \"" + n.type.type + "\".", n.init.position)
		}
	    }
	}

	if (n.init == null || !n.init.isConstant || !n.localDef.flags.isFinal) {
	    n.localDef.setNotConstant
	}
	else {
	    n.localDef.setConstantValue(n.init.constantValue)
	}

	return n
    }

    def visit(n: Local_c, context: Context) = {
        val c = context

        n.localInstanceRef when li => {
          n.setType(li.typ)

          if (! c.isLocal(li.name)) {
            // this local is defined in an outer class
            li.flags.isFinal orelse
            "Local variable \"" + li.name + "\" is accessed from an inner class, and must be declared " + "final."
          }
        }

	val li = c.findLocal(n.name.id)
        n.localInstance(li)
    }

    def visit(n: Special_c, context: Context) = {
      val c = context

      val r = Types.ref[ClassType](null)

      r when t => {
        // trying to access "this" or "super" from a static context.
        ! (t == null || (c.inStaticContext && ts.typeEquals(t, c.currentClass, c))) orelse
          "Cannot access a non-static member or refer to \"this\" or \"super\" from a static context."

        if (n.kind == Special.THIS) {
          n.setType(t)
        }
        else if (n.kind == Special.SUPER) {
          n.setType(t.superClass)
        }
      }

      if (n.qualifier == null) 
        // an unqualified "this" or "super"
        r.update(c.currentClass)
      else {
        n.qualifier.typeRef when t => {
          t.isClass orelse
            "Invalid qualifier of type " + t + " for \"this\" or \"super\"."
          c.currentClass.hasEnclosingInstance(t) orelse
            "The nested class \"" + c.currentClass + "\" does not have " + "an enclosing instance of type \"" + t + "\"."
          r.update(t)
        }
      }
    }

    def visit(n: ConstructorCall_c, context: Context) = {
	n = (ConstructorCall_c) acceptChildren(n)

	ConstructorCall_c n1 = n

	Context c = context

	ClassType ct = c.currentClass
	Type superType = ct.superClass

	// The qualifier specifies the enclosing instance of this inner
	// class.
	// The type of the qualifier must be the outer class of this
	// inner class or one of its super types.
	//
	// Example:
	//
	// class Outer {
	// class Inner { }
	// }
	//
	// class ChildOfInner extends Outer.Inner {
	// ChildOfInner { (new Outer).super }
	// }
	if (n.qualifier != null) {
	    if (n.kind != ConstructorCall_c.SUPER) {
		throw new SemanticException("Can only qualify a \"super\"" + "constructor invocation.", n.position)
	    }

	    if (!superType.isClass || !superType.toClass.isInnerClass || superType.toClass.inStaticContext) {
		throw new SemanticException("The class \"" + superType + "\"" + " is not an inner class, or was declared in a static "
		                            + "context a qualified constructor invocation cannot " + "be used.", n.position)
	    }

	    Type qt = n.qualifier.type

	    if (!qt.isClass || !qt.isSubtype(superType.toClass.outer, c)) {
		throw new SemanticException("The type of the qualifier " + "\"" + qt + "\" does not match the immediately enclosing "
		                            + "class  of the super class \"" + superType.toClass.outer + "\".", n.qualifier.position)
	    }
	}

	if (n.kind == ConstructorCall_c.SUPER) {
	    if (!superType.isClass) {
		throw new SemanticException("Super type of " + ct + " is not a class.", n.position)
	    }

	    Expr q = n.qualifier

	    // If the super class is an inner class (i.e., has an enclosing
	    // instance of its container class), then either a qualifier
	    // must be provided, or ct must have an enclosing instance of
	    // the superclass's container class, or a subclass thereof.
	    if (q == null && superType.isClass && superType.toClass.isInnerClass) {
		ClassType superContainer = superType.toClass.outer
		// ct needs an enclosing instance of superContainer,
		// or a subclass of superContainer.
		ClassType e = ct

		while (e != null) {
		    if (e.isSubtype(superContainer, c) && ct.hasEnclosingInstance(e)) {
			q = nf.This(n.position, nf.CanonicalTypeNode(n.position, e)).type(e)
			q = (Expr) setContext(q, c)
			q = (Expr) accept(q)
			break
		    }
		    e = e.outer
		}

		if (e == null) {
		    throw new SemanticException(ct + " must have an enclosing instance" + " that is a subtype of " + superContainer, n.position)
		}
		if (e == ct) {
		    throw new SemanticException(ct + " is a subtype of " + superContainer + " an enclosing instance that is a subtype of "
		                                + superContainer + " must be specified in the super constructor call.", n.position)
		}
	    }

	    if (n.qualifier != q)
		n1 = (ConstructorCall_c) n1.qualifier(q)
	}

	List<Type> argTypes = new ArrayList<Type>

	for (Expr e : n1.arguments) {
	    argTypes.add(e.type)
	}

	if (n.kind == ConstructorCall_c.SUPER) {
	    ct = ct.superClass.toClass
	}

	ConstructorInstance ci = ts.findConstructor(ct, ts.ConstructorMatcher(ct, argTypes, c))

	return n1.constructorInstance(ci)
    }

    def visit(n: New_c, context: Context) = {
	New_c n1 = typeCheckerHeader(n, context)

	ClassBody body = (ClassBody) accept(n1.body)
	n1 = (New_c) n1.body(body)

	return tcNew(n, n1, context)
    }

    Node tcNew(New_c old, New_c n, Context context) throws SemanticException {

	List<Type> argTypes = new ArrayList<Type>(n.arguments.size)

	for (Expr e : n.arguments) {
	    argTypes.add(e.type)
	}

	typeCheckFlags(n)
	typeCheckNested(n)

	ClassType ct = n.objectType.type.toClass
	ConstructorInstance ci

	if (!ct.flags.isInterface) {
	    Context c = context
	    if (n.anonType != null) {
		c = c.pushClass(n.anonType, n.anonType.asType)
	    }
	    ci = ts.findConstructor(ct, ts.ConstructorMatcher(ct, argTypes, c))
	}
	else {
	    ConstructorDef dci = ts.defaultConstructor(n.position, Types.<ClassType> ref(ct))
	    ci = dci.asInstance
	}

	New n1 = n.constructorInstance(ci)

	if (n.anonType != null) {
	    // The type of the new expression is the anonymous type, not the
	    // base type.
	    ct = n.anonType.asType
	}

	return n1.type(ct)
    }

    private void typeCheckFlags(New_c n) throws SemanticException {
	ClassType ct = n.objectType.type.toClass

	if (n.body == null) {
	    if (ct.flags.isInterface) {
		throw new SemanticException(
		                            "Cannot instantiate an interface.", n.position)
	    }

	    if (ct.flags.isAbstract) {
		throw new SemanticException(
		                            "Cannot instantiate an abstract class.", n.position)
	    }
	}
	else {
	    if (ct.flags.isFinal) {
		throw new SemanticException(
		                            "Cannot create an anonymous subclass of a final class.",
		                            n.position)
	    }

	    if (ct.flags.isInterface && ! n.arguments.isEmpty) {
		throw new SemanticException(
		                            "Cannot pass arguments to an anonymous class that " +
		                            "implements an interface.",
		                            n.arguments.get(0).position)
	    }
	}
    }

    private void typeCheckNested(New_c n) throws SemanticException {
	if (n.qualifier != null) {
	    // We have not disambiguated the type node yet.

	    // Get the qualifier type first.
	    Type qt = n.qualifier.type

	    if (! qt.isClass) {
		throw new SemanticException(
		                            "Cannot instantiate member class of a non-class type.",
		                            n.qualifier.position)
	    }

	    // Disambiguate the type node as a member of the qualifier type.
	    ClassType ct = n.objectType.type.toClass

	    // According to JLS2 15.9.1, the class type being
	    // instantiated must be inner.
	    if (! ct.isInnerClass) {
		throw new SemanticException(
		                            "Cannot provide a containing instance for non-inner class " +
		                            ct.fullName + ".", n.qualifier.position)
	    }
	}
	else {
	    ClassType ct = n.objectType.type.toClass

	    if (ct.isMember) {
		for (ClassType t = ct t.isMember t = t.outer) {
		    if (! t.flags.isStatic) {
			throw new SemanticException(
			                            "Cannot allocate non-static member class \"" +
			                            t + "\".", n.position)
		    }
		}
	    }
	}
    }

    private New_c typeCheckerHeader(New_c n, Context context) throws SemanticException {
	n = typeCheckObjectType(context, n)

	Expr qualifier = n.qualifier
	TypeNode tn = n.objectType
	List<Expr> arguments = n.arguments
	ClassBody body = n.body

	if (body != null) {
	    Ref<? extends Type> ct = tn.typeRef
	    ClassDef anonType = n.anonType

	    assert anonType != null

	    if (!ct.get.toClass.flags.isInterface) {
		anonType.superType(ct)
	    }
	    else {
		anonType.superType(Types.<Type> ref(ts.Object))
		assert anonType.interfaces.isEmpty || anonType.interfaces.get(0) == ct
		if (anonType.interfaces.isEmpty)
		    anonType.addInterface(ct)
	    }
	}

	arguments = (List<Expr>) accept(arguments)

	n = (New_c) n.qualifier(qualifier)
	n = (New_c) n.objectType(tn)
	n = (New_c) n.arguments(arguments)
	n = (New_c) n.body(body)

	return n
    }

    private New_c typeCheckObjectType(Context c, New_c n) throws SemanticException {
	Expr qualifier = n.qualifier
	TypeNode tn = n.objectType
	List<Expr> arguments = n.arguments
	ClassBody body = n.body

	if (qualifier == null) {
	    tn = (TypeNode) accept(tn)
	    // if (childtc.hasErrors) throw new SemanticException

	    if (tn.type instanceof UnknownType) {
		throw new SemanticException
	    }

	    if (tn.type.isClass) {
		ClassType ct = tn.type.toClass

		if (ct.isMember && !ct.flags.isStatic) {
		    New k = findQualifier(c, n, ct)
		    qualifier = (Expr) accept(k.qualifier)
		}
	    }
	    else {
		throw new SemanticException("Cannot instantiate type " + tn.type + ".")
	    }
	}
	else {
	    qualifier = (Expr) accept(n.qualifier)

	    if (tn instanceof AmbTypeNode && ((AmbTypeNode) tn).prefix == null) {
		// We have to disambiguate the type node as if it were a
		// member of the
		// static type, outer, of the qualifier. For Java this is
		// simple: type
		// nested type is just a name and we
		// use that name to lookup a member of the outer class. For
		// some
		// extensions (e.g., PolyJ), the type node may be more
		// complex than
		// just a name. We'll just punt here and let the extensions
		// handle
		// this complexity.

		Name name = ((AmbTypeNode) tn).name.id
		assert name != null

		if (!qualifier.type.isClass) {
		    throw new SemanticException("Cannot instantiate member class of non-class type.", n.position)
		}
		Type ct = ts.findMemberType(qualifier.type, name, c)
		((Ref<Type>) tn.typeRef).update(ct)
		tn = nf.CanonicalTypeNode(n.objectType.position, tn.typeRef)
		tn = (TypeNode) copyAttributesFrom(tn, n.objectType)
	    }
	    else {
		throw new SemanticException("Only simply-named member classes may be instantiated by a qualified new expression.", tn.position)
	    }
	}

	n = (New_c) n.qualifier(qualifier)
	n = (New_c) n.objectType(tn)
	n = (New_c) n.arguments(arguments)
	n = (New_c) n.body(body)

	return n
    }

    private New findQualifier(Context c, New_c n, ClassType ct) throws SemanticException {
	// If we're instantiating a non-static member class, add a "this"
	// qualifier.

	// Search for the outer class of the member.  The outer class is
	// not just ct.outer it may be a subclass of ct.outer.
	Type outer = null

	Name name = ct.name
	ClassType t = c.currentClass

	// We're in one scope too many.
	if (t == n.anonType) {
	    t = t.outer
	}

	// Search all enclosing classes for the type.
	while (t != null) {
	    try {
		Type mt = ts.findMemberType(t, name, c)

		if (mt instanceof ClassType) {
		    ClassType cmt = (ClassType) mt
		    if (cmt.def == ct.def) {
			outer = t
			break
		    }
		}
	    }
	    catch (SemanticException e) {
	    }

	    t = t.outer
	}

	if (outer == null) {
	    throw new SemanticException("Could not find non-static member class \"" +
	                                name + "\".", n.position)
	}

	// Create the qualifier.
	Expr q

	if (outer.typeEquals(c.currentClass, c)) {
	    q = nf.This(n.position.startOf)
	}
	else {
	    q = nf.This(n.position.startOf,
	                nf.CanonicalTypeNode(n.position, outer))
	}

	q = (Expr) setContext(q, c)
	q = (Expr) accept(q)

	New k = n.qualifier(q)
	return k
    }

    def visit(n: Case_c, context: Context): Unit = {
      if (n.expr == null)
        return

      n.expr.typeRef when t => {
        ts.isImplicitCastValid(t, ts.Int, context) || 
        ts.isImplicitCastValid(t, ts.Char, context) orelse
          "Case label must be an byte, char, short, or int."
      }

      n.expr.constantValueRef when o => {
        o == ConstantValueVisitor.NOT_A_CONSTANT orelse
          "Case label must be an integral constant."
      }
    }

    def visit(n: Conditional_c, context: Context) = {
      val e1 = n.consequent
      val e2 = n.alternative

      n.cond.typeRef when t => {
        t.isBoolean orelse "Condition of ternary expression must be of type boolean."
      }

      e1.typeRef when t1 => {
        e2.typeRef when t2 => {
          if (ts.typeEquals(t1, t2, context)) {
            // If the second and third operands have the same type (which may
            // be the null type), then that is the type of the conditional
            // expression.
            n.setType(t1)
          }
          else if (t1.isByte && t2.isShort || t2.isByte && t2.isShort) {
            // - If one of the operands is of type byte and the other is of
            // type short, then the type of the conditional expression is
            // short.
            n.setType(ts.Short)
          }
          else if (t1.isIntOrLess && t2.isInt && ts.numericConversionValid(t1, e2.constantValue, context)) {
            // - If one of the operands is of type T where T is byte, short,
            // or char, and the other operand is a constant expression of
            // type int whose value is representable in type T, then the type
            // of the conditional expression is T.
            n.setType(t1)
          }
          else if (t2.isIntOrLess && t1.isInt && ts.numericConversionValid(t2, e1.constantValue, context)) {
            // Symmetric with previous case.
            n.setType(t2)
          }
          else if (t1.isNumeric && t2.isNumeric) {
            // - Otherwise, binary numeric promotion (Sec. 5.6.2) is applied
            // to the operand types, and the type of the conditional
            // expression is the promoted type of the second and third
            // operands. Note that binary numeric promotion performs value
            // set conversion (Sec. 5.1.8).
            n.setType(ts.promote(t1, t2))
          }
          else if (t1.isNull && t2.isReference)
              // If one of the second and third operands is of the null type and
              // the type of the other is a reference type, then the type of the
              // conditional expression is that reference type.
              n.setType(t2)
          else if (t2.isNull && t1.isReference)
              // If one of the second and third operands is of the null type and
              // the type of the other is a reference type, then the type of the
              // conditional expression is that reference type.
              n.setType(t1)

          else if (t1.isReference && t2.isReference) {
              // If the second and third operands are of different reference
              // types, then it must be possible to convert one of the types to
              // the other type (call this latter type T) by assignment
              // conversion (Sec.  5.2) the type of the conditional expression
              // is T. It is a compile-time error if neither type is assignment
              // compatible with the other type.
              if (ts.isImplicitCastValid(t1, t2, context)) {
                  n.setType(t2)
              }
              if (ts.isImplicitCastValid(t2, t1, context)) {
                  n.setType(t1)
              }
          }

          error "Could not determine type of ternary conditional expression cannot assign " + t1 + " to " + t2 + " or vice versa." $ n
        }
      }
    }

    def visit(n: AmbPrefix_c, context: Context) = {
	n = (AmbPrefix_c) acceptChildren(n)

	Position pos = n.position
	Node n1 = disamb(n, context, n.prefix, n.nameNode)
	n1 = copyAttributesFrom(n1, n)

	if (n1 instanceof Prefix) {
	    if (n1 != n)
		n1 = n1.accept(this, context)
	    return n1
	}
	throw new SemanticException("Could not find " + (n.prefix != null ? n.prefix + "." : "") + n.nameNode, pos)
    }

    def visit(n: AmbExpr_c, context: Context) = {
	n = (AmbExpr_c) acceptChildren(n)

	Position pos = n.position
	Node n1 = disamb(n, context, null, n.name)
	n1 = copyAttributesFrom(n1, n)

	if (n1 instanceof Expr) {
	    if (n1 != n)
		n1 = n1.accept(this, context)
	    return n1
	}

	throw new SemanticException("Could not find field or local " + "variable \"" + n.name + "\".", pos)
    }

    def visit(n: Field_c, context: Context) = {
	n = (Field_c) acceptChildren(n)

	Context c = context

	FieldInstance fi = ts.findField(n.target.type, ts.FieldMatcher(n.target.type, n.name.id, c))

	if (fi == null) {
	    throw new InternalCompilerError("Cannot access field on node of type " + n.target.getClass.getName + ".")
	}

	Field_c f1 = (Field_c) n.fieldInstance(fi).type(fi.type)
	f1.checkConsistency(c)

	return f1
    }

    def visit(n: AmbTypeNode_c, context: Context) = {
	n = (AmbTypeNode_c) acceptChildren(n)

	assert n.context == context : "context mismatch for " + n
	assert context != null : "null context for " + n

	SemanticException ex

	try {
	    Prefix prefix = n.prefix
	    Id name = n.name

	    assert name != null : "null name for " + n

	    Node n1 = disamb(n, context, prefix, name)
	    n1 = copyAttributesFrom(n1, n)

	    if (n1 instanceof TypeNode) {
		TypeNode tn = (TypeNode) n1
		Ref<Type> sym = n.typeRef
		sym.update(tn.typeRef.get)

		// Reset the resolver goal to one that can run when the ref
		// is deserialized.
//		Goal resolver = Globals.Scheduler.LookupGlobalType(sym)
//		resolver.update(Goal.Status.SUCCESS)
//		sym.setResolver(resolver)


		if (n1 != n)
		    n1 = n1.accept(this, context)

		return n1
	    }

	    ex = new SemanticException("Could not find type \"" + (n.prefix == null ? n.name.id : n.prefix.toString + "." + n.name.id)
	                               + "\".", n.position)
	}
	catch (SemanticException e) {
	    ex = e
	}

	// Mark the type as an error, so we don't try looking it up again.
	Ref<Type> sym = n.typeRef
	sym.update(this.ts.unknownType(n.position))

	throw ex
    }

    private Node disamb(Ambiguous n, Context context, Prefix prefix, Id name) throws SemanticException {
	if (prefix instanceof Ambiguous) {
	    throw new SemanticException(
	    "Cannot disambiguate node with ambiguous prefix.")
	}

	Node result = null

	if (prefix instanceof PackageNode) {
	    PackageNode pn = (PackageNode) prefix
	    result = disambPackagePrefix(n.position, name, n, context, pn)
	}
	else if (prefix instanceof TypeNode) {
	    TypeNode tn = (TypeNode) prefix
	    result = disambTypeNodePrefix(n.position, prefix, name, n, context, tn)
	}
	else if (prefix instanceof Expr) {
	    Expr e = (Expr) prefix
	    result = disambExprPrefix(n.position, name, n, context, e)
	}
	else if (prefix == null) {
	    result = disambNoPrefix(n.position, prefix, name, n, context)
	}

	assert ! (result instanceof Ambiguous)
	return result
    }

    private Node disambNoPrefix(Position pos, Prefix prefix, Id name, Ambiguous amb, Context c) throws SemanticException {
	if (exprOk(amb)) {
	    // First try local variables and fields.
	    VarInstance vi = c.findVariableSilent(name.id)

	    if (vi != null) {
		Node n = disambVarInstance(vi, pos, name, c)
		if (n != null) return n
	    }
	}

	// no variable found. try types.
	if (typeOk(amb)) {
	    try {
		Named n = c.find(ts.TypeMatcher(name.id))
		if (n instanceof Type) {
		    Type type = (Type) n
		    return makeTypeNode(type, pos, amb)
		}
	    } catch (NoClassException e) {
		if (! name.id.toString.equals(e.getClassName)) {
		    // hmm, something else must have gone wrong
		    // rethrow the exception
		    throw e
		}

		// couldn't find a type named name. 
		// It must be a package--ignore the exception.
	    }
	}

	// Must be a package then...
	if (packageOk(amb)) {
	    try {
		Package p = ts.packageForName(QName.make(null, name.id))
		PackageNode pn = nf.PackageNode(pos, Types.ref(p))
		pn = (PackageNode) setContext(pn, c)
		pn = (PackageNode) accept(pn)
		return pn
	    }
	    catch (SemanticException e) {
	    }
	    Package p = ts.createPackage(QName.make(null, name.id))
	    PackageNode pn = nf.PackageNode(pos, Types.ref(p))
	    pn = (PackageNode) setContext(pn, c)
	    pn = (PackageNode) accept(pn)
	    return pn
	}

	return null
    }

    private boolean packageOk(Ambiguous amb) {
	return ! (amb instanceof Receiver) &&
	(amb instanceof QualifierNode || amb instanceof Prefix)
    }

    private Node disambVarInstance(VarInstance vi, Position pos, Id name, Context c) throws SemanticException {
	Node n = null
	if (vi instanceof FieldInstance) {
	    FieldInstance fi = (FieldInstance) vi
	    Receiver r = makeMissingFieldTarget(c, pos, name, fi)
	    n = nf.Field(pos, r, name).fieldInstance(fi).targetImplicit(true)
	    return n
	}
	else if (vi instanceof LocalInstance) {
	    LocalInstance li = (LocalInstance) vi
	    n = nf.Local(pos, name).localInstance(li)
	}
	if (n != null) {
	    n = setContext(n, c)
	    n = accept(n)
	}
	return n
    }

    private Receiver makeMissingFieldTarget(Context c, Position pos, Id name, FieldInstance fi) throws SemanticException {
	Receiver r

	if (fi.flags.isStatic) {
	    r = nf.CanonicalTypeNode(pos.startOf, fi.container)
	} else {
	    // The field is non-static, so we must prepend with
	    // "this", but we need to determine if the "this"
	    // should be qualified.  Get the enclosing class which
	    // brought the field into scope.  This is different
	    // from fi.container.  fi.container returns a super
	    // type of the class we want.
	    ClassType scope = c.findFieldScope(name.id)
	    assert scope != null

	    if (! ts.typeEquals(scope, c.currentClass, c)) {
		r = (Special) nf.This(pos.startOf, nf.CanonicalTypeNode(pos.startOf, scope))
	    }
	    else {
		r = (Special) nf.This(pos.startOf)
	    }
	}

	r = (Receiver) setContext(r, c)
	r = (Receiver) accept(r)

	return r
    }

    private TypeNode makeTypeNode(Type type, final Position pos, Ambiguous amb) {
	if (amb instanceof TypeNode) {
	    TypeNode tn = (TypeNode) amb
	    Ref<Type> sym = tn.typeRef
	    sym.update(type)

	    final QName name = ((ClassType) type).fullName
	    
	    // Reset the resolver goal to one that can run when the ref is deserialized.
	    sym.setResolver(new Ref. Callable<Type> {
	        public Type compute {
	            try {
			return (Type) ts.systemResolver.find(name)
		    }
		    catch (SemanticException e) {
			return ts.unknownType(pos)
		    }
	        }
	    })

	    TypeNode n = nf.CanonicalTypeNode(pos, sym)
	    n = (TypeNode) setContext(n, amb.context)
	    return n
	}

	TypeNode n = nf.CanonicalTypeNode(pos, type)
	n = (TypeNode) setContext(n, amb.context)
	return n
    }

    private boolean typeOk(Ambiguous amb) {
	return ! (amb instanceof Expr) &&
	(amb instanceof TypeNode || amb instanceof QualifierNode ||
		amb instanceof Receiver || amb instanceof Prefix)
    }

    private boolean exprOk(Ambiguous amb) {
	return ! (amb instanceof QualifierNode) &&
	! (amb instanceof TypeNode) &&
	(amb instanceof Expr || amb instanceof Receiver ||
		amb instanceof Prefix)
    }

    private Node disambExprPrefix(Position pos, Id name, Ambiguous amb, Context c, Expr e) throws SemanticException {
	// Must be a non-static field.
	if (exprOk(amb)) {
	    Node n = nf.Field(pos, e, name)
	    n = setContext(n, c)
	    n = accept(n)
	    return n
	}
	return null
    }

    private Node disambTypeNodePrefix(Position pos, Prefix prefix, Id name, Ambiguous amb, Context c, TypeNode tn) throws SemanticException {
	// Try static fields.
	Type t = tn.type

	if (exprOk(amb)) {
	    try {
		FieldInstance fi = ts.findField(t, ts.FieldMatcher(t, name.id, c))
		Node n = nf.Field(pos, tn, name).fieldInstance(fi)
		n = setContext(n, c)
		n = accept(n)
		return n
	    } catch (NoMemberException e) {
		if (e.getKind != NoMemberException.FIELD) {
		    // something went wrong...
		    throw e
		}

		// ignore so we can check if we're a member class.
	    }
	}

	// Try member classes.
	if (t.isClass && typeOk(amb)) {
	    Resolver tc = t.toClass.resolver
	    Named n
	    try {
		n = tc.find(ts.MemberTypeMatcher(t, name.id, c))
	    }
	    catch (NoClassException e) {
		return null
	    }
	    if (n instanceof Type) {
		Type type = (Type) n
		return makeTypeNode(type, pos, amb)
	    }
	}

	return null
    }

    private Node disambPackagePrefix(Position pos, Id name, Ambiguous amb, Context c, PackageNode pn) throws SemanticException {
	Resolver pc = ts.packageContextResolver(pn.package_.get)

	Named n

	try {
	    n = pc.find(ts.TypeMatcher(name.id))
	}
	catch (SemanticException e) {
	    n = null
	}

	Qualifier q = null

	if (n instanceof Qualifier) {
	    q = (Qualifier) n
	}
	else if (n == null) {
	    Package p = ts.createPackage(pn.package_, name.id)
	    q = p
	}
	else {
	    return null
	}

	if (q.isPackage && packageOk(amb)) {
	    Node n1 = nf.PackageNode(pos, Types.ref(q.toPackage))
	    n1 = setContext(n1, c)
	    n1 = accept(n1)
	    return n1
	}
	else if (q.isType && typeOk(amb)) {
	    return makeTypeNode(q.toType, pos, amb)
	}

	return null
    }

    def visit(n: AmbQualifierNode_c, context: Context) = {
	try {
	    val n1 = disamb(n, context, n.prefix, n.name)
	    n1 = copyAttributesFrom(n1, n)

	    if (n1 instanceof QualifierNode) {
		QualifierNode qn = (QualifierNode) n1
		Qualifier q = qn.qualifierRef.get
		Ref<Qualifier> sym = n.qualifierRef
		sym.update(q)

		if (n1 != n)
		    n1 = n1.accept(this, context)

		return n1
	    }

	    ex = new SemanticException("Could not find type or package \""
	                               + (n.qualifier == null ? n.name.toString : n.prefix.toString + "." + n.name.toString) + "\".", n.position)
	}
	catch (SemanticException e) {
	    ex = e
	}

	// Mark the type as an error, so we don't try looking it up again.
	Ref<Qualifier> sym = n.qualifierRef
	sym.update(this.ts.unknownQualifier(n.position))

	throw ex
    }

    def visit(n: AmbReceiver_c, context: Context) = {
	Node n1 = visit((AmbPrefix_c) n, context)

	if (n1 instanceof Receiver) {
	    return n1
	}

	throw new SemanticException("Could not find type, field, or " + "local variable \""
	                            + (n.prefix == null ? n.nameNode.toString : n.prefix.toString + "." + n.nameNode.toString) + "\".", n.position)
    }

    def visit(n: ArrayTypeNode_c, context: Context) = {
	n = (ArrayTypeNode_c) acceptChildren(n)
	CanonicalTypeNode n1 = nf.CanonicalTypeNode(n.position, ts.arrayOf(n.position, n.base.typeRef))
	n1 = (CanonicalTypeNode) copyAttributesFrom(n1, n)
	return n1
    }

    private Node copyAttributesFrom(Node neu, Node old) {
	if (neu == null)
	    return null
	Context context = old.context
	neu = setContext(neu, context)
	return neu
    }

    private Node setContext(Node n, Context context) {
	if (n == null)
	    return null

	ContextVisitor v = new ContextVisitor(job, ts, nf) {
	    @Override
	    protected Node leaveCall(Node n) throws SemanticException {
		return n.context(context.freeze)
	    }
	}
	v = v.context(context)
	n = n.visit(v)
	return n
    }

    def visit(n: CanonicalTypeNode_c, context: Context) = {
      n.typeRef when t => {
        if (t.isClass) {
          val ct = t.toClass
          if (ct.isTopLevel || ct.isMember) {
            ts.classAccessible(ct.def, context) orelse
              "Cannot access class \"" + ct + "\" from the body of \"" + context.currentClass + "\"."
          }
        }
      }
    }

    def visit(n: Catch_c, context: Context) = {
      n.formal.typ.typeRef when t => {
        t.isThrowable orelse
          "Can only throw subclasses of \"" + ts.Throwable + "\"."
      }
    }

    def visit(n: Import_c, context: Context) = {
      // Make sure the imported name exists.
      if (n.kind == Import_c.PACKAGE && ts.systemResolver.packageExists(n.name)) {
      }
      else {
        val n1 = try {
          ts.systemResolver.find(n.name)
        }
        catch {
          case e: SemanticException =>
            throw new SemanticException("Package or class " + n.name + " not found.")
        }

        n1 match {
          case t: Type => {
            if (t.isClass) {
              val ct = t.toClass
              ts.classAccessibleFromPackage(ct.def, context.package_)
                orelse "Class " + ct + " is not accessible."
            }
          }
        }
      }
    }

    def visit(n: Return_c, context: Context) = {
	n = (Return_c) acceptChildren(n)

	Context c = context

	CodeDef ci = c.currentCode

	if (ci instanceof InitializerDef) {
	    throw new SemanticException("Cannot return from an initializer block.", n.position)
	}

	if (ci instanceof ConstructorDef) {
	    if (n.expr != null) {
		throw new SemanticException("Cannot return a value from " + ci + ".", n.position)
	    }

	    return n
	}

	if (ci instanceof FunctionDef) {
	    FunctionDef fi = (FunctionDef) ci
	    Type returnType = Types.get(fi.returnType)

	    if (returnType == null) {
		throw new InternalCompilerError("Null return type for " + fi)
	    }

	    if (returnType instanceof UnknownType) {
		throw new SemanticException
	    }

	    if (returnType.isVoid) {
		if (n.expr != null) {
		    throw new SemanticException("Cannot return a value from " + fi + ".", n.position)
		}
		else {
		    return n
		}
	    }
	    else if (n.expr == null) {
		throw new SemanticException("Must return a value from " + fi + ".", n.position)
	    }

	    if (ts.isImplicitCastValid(n.expr.type, returnType, c)) {
		return n
	    }

	    if (ts.numericConversionValid(returnType, n.expr.constantValue, c)) {
		return n
	    }

	    throw new SemanticException("Cannot return expression of type " + n.expr.type + " from " + fi + ".", n.expr.position)
	}

	throw new SemanticException("Cannot return from this context.", n.position)
    }

    def visit(n: Throw_c, context: Context) = {
      n.expr.typeRef when t => {
	t.isThrowable orelse "Can only throw subclasses of \"" + ts.Throwable + "\"."
      }
    }

    def visit(n: MethodDecl_c, context: Context) = {
      for (tn <- n.throwTypes) {
        tn.typeRef when t => {
          t.isThrowable orelse
            "Type \"" + t + "\" is not a subclass of \"" + ts.Throwable + "\"."
	}
      }
    }

    def visit(n: FieldDecl_c, context: Context) = {
	n = (FieldDecl_c) acceptChildren(n)

	if (n.init != null && !(n.init.type instanceof UnknownType)) {
	    if (n.init instanceof ArrayInit) {
		typeCheckElements(context, n.type.type, (ArrayInit) n.init)
	    }
	    else {
		if (!ts.isImplicitCastValid(n.init.type, n.type.type, context) && !ts.typeEquals(n.init.type, n.type.type, context)
			&& !ts.numericConversionValid(n.type.type, n.init.constantValue, context)) {

		    throw new SemanticException("The type of the variable " + "initializer \"" + n.init.type + "\" does not match that of "
		                                + "the declaration \"" + n.type.type + "\".", n.init.position)
		}
	    }
	}

	if (n.init == null || !n.init.isConstant || !n.fieldDef.flags.isFinal) {
	    n.fieldDef.setNotConstant
	}
	else {
	    n.fieldDef.setConstantValue(n.init.constantValue)
	}

	return n
    }

    def visit(n: ConstructorDecl_c, context: Context) = {
      for (tn <- n.throwTypes) {
        tn.typeRef when t => {
          t.isThrowable orelse
            "Type \"" + t + "\" is not a subclass of \"" + ts.Throwable + "\"."
	}
      }
    }

    def visit(n: IntLit_c, context: Context) = {
      n.kind match {
        case k if k == IntLit.INT => n.setType(ts.Int)
        case k if k == IntLit.LONG => n.setType(ts.Long)
      }
    }

    def visit(n: FloatLit_c, context: Context) = {
      n.kind match {
        case k if k == FloatLit.FLOAT => n.setType(ts.Float)
        case k if k == FloatLit.DOUBLE => n.setType(ts.Double)
      }
    }

    def visit(n: StringLit_c, context: Context) = {
	n.setType(ts.String)
    }

    def visit(n: CharLit_c, context: Context) = {
	n.setType(ts.Char)
    }

    def visit(n: BooleanLit_c, context: Context) = {
	n.setType(ts.Boolean)
    }

    def visit(n: NullLit_c, context: Context) = {
	n.setType(ts.Null)
    }

    def visit(n: ClassLit_c, context: Context) = {
      n.setType(ts.Class)
    }

    def visit(n: Instanceof_c, context: Context) = {
      n.compareType.typeRef when t => {
        t.isReference orelse "Type operand " + t + " must be a reference type."

        n.expr.typeRef when s => {
          ts.isCastValid(s, t, context) orelse
            "Expression operand type " + s + " incompatible with type operand " + t + "."
        }
      }

      n.setType(ts.Boolean)
    }

    def visit(n: ClassDecl_c, context: Context) = {
	ClassDecl_c n1 = typeCheckSupers(context, n)

	ClassBody body = (ClassBody) accept(n1.body)
	Node n2 = (ClassDecl_c) n1.body(body)

	return n2
    }

    private ClassDecl_c typeCheckSupers(Context context, ClassDecl_c n) throws SemanticException {
	n.classDef.inStaticContext(context.inStaticContext)

	FlagsNode flags = n.flags
	Id name = n.name
	TypeNode superClass = n.superClass
	List<TypeNode> interfaces = n.interfaces

	flags = (FlagsNode) accept(n.flags)
	name = (Id) accept(n.name)
	superClass = (TypeNode) accept(n.superClass)
	interfaces = (List<TypeNode>) accept(n.interfaces)

	if (n.superClass != null)
	    assert n.classDef.superType == n.superClass.typeRef

	n = (ClassDecl_c) n.flags(flags)
	n = (ClassDecl_c) n.name(name)
	n = (ClassDecl_c) n.superClass(superClass)
	n = (ClassDecl_c) n.interfaces(interfaces)

	checkSupertypeCycles(n)

	return n
    }

    private void checkSupertypeCycles(ClassDecl_c n) throws SemanticException {
	Ref<? extends Type> stref = n.classDef.superType
	if (stref != null) {
	    Type t = stref.get
	    if (t instanceof UnknownType)
		throw new SemanticException // already reported
		if (!t.isClass || t.toClass.flags.isInterface) {
		    throw new SemanticException("Cannot extend type " + t + " not a class.", n.superClass != null ? n.superClass.position : n.position)
		}
		ts.checkCycles((ReferenceType) t)
	}

	for (Ref<? extends Type> tref : n.classDef.interfaces) {
	    Type t = tref.get
	    //		assert !(t instanceof UnknownType)
	    if (!t.isClass || !t.toClass.flags.isInterface) {
		String s = n.classDef.flags.isInterface ? "extend" : "implement"
		throw new SemanticException("Cannot " + s + " type " + t + " not an interface.", n.position)
	    }
	    ts.checkCycles((ReferenceType) t)
	}
    }

    def visit(n: Formal_c, context: Context) = {
	n = (Formal_c) acceptChildren(n)
	// Check if the variable is multiply defined.
	Context c = context

	LocalInstance outerLocal = null

	try {
	    outerLocal = c.findLocal(n.localDef.name)
	}
	catch (SemanticException e) {
	    // not found, so not multiply defined
	}

	if (outerLocal != null && !n.localDef.equals(outerLocal.def) && c.isLocal(n.localDef.name)) {
	    throw new SemanticException(
	                                "Local variable \"" + n.name + "\" multiply defined.  " + "Previous definition at " + outerLocal.position + ".",
	                                n.position)
	}

	try {
	    ts.checkLocalFlags(n.flags.flags)
	}
	catch (SemanticException e) {
	    throw new SemanticException(e.getMessage, n.position)
	}

	return n
    }

    def visit(n: SourceFile_c, context: Context) = {
	n = (SourceFile_c) acceptChildren(n)

	Set<Name> names = new HashSet<Name>
	boolean hasPublic = false

	for (TopLevelDecl d : n.decls) {
	    if (d.name == null)
		continue

	    Name s = d.name.id

	    if (names.contains(s)) {
		throw new SemanticException("Duplicate declaration: \"" + s + "\".", d.position)
	    }

	    names.add(s)

	    if (d.flags.flags.isPublic) {
		if (hasPublic) {
		    throw new SemanticException("The source contains more than one public declaration.", d.position)
		}

		hasPublic = true
	    }
	}

	return n
    }
}
