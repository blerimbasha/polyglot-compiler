package jltools.frontend;

import jltools.ast.*;
import jltools.types.*;
import jltools.util.*;
import jltools.visit.*;
import jltools.main.Options;
import jltools.main.Report;

import java.io.*;
import java.util.*;

/**
 * This is the main entry point for the compiler. It contains a work list that
 * contains entries for all classes that must be compiled (or otherwise worked
 * on).
 */
public class Compiler
{
    /** Command-line options */
    private Options options;

    /**
     * The system class resolver.  The class resolver contains a map from class
     * names to ClassTypes.  A Job looks up classes first in its import table
     * and then in the system resolver.  The system resolver first tries to
     * find the class in parsed class resolver
     */
    private Resolver systemResolver;

    /**
     * The parsed class resolver.  This resolver contains classes parsed from
     * source files.
     */
    private TableResolver parsedResolver;

    /**
     * The loaded class resolver.  This resolver automatically loads types from
     * class files and from source files not mentioned on the command line.
     */
    private LoadedClassResolver loadedResolver;

    /** The type system. */
    protected TypeSystem type_system;
    
    /** The node factory creates AST node objects. */
    protected NodeFactory node_factory;

    /**
     * The source loader is responsible for loading source files from the
     * source path.
     */
    protected SourceLoader source_loader;

    /**
     * The target factory is responsible for naming and opening output files
     * given a package name and a class or source file name.
     */
    protected TargetFactory target_factory;

    /** The error queue handles outputting error messages. */
    ErrorQueue eq;

    /** The work list. */
    LinkedList worklist;

    /** A map from sources to jobs. */
    Map jobs;

    /**
     * The output files generated by the compiler.  This is used to to call the
     * post-compiler (e.g., javac).
     */
    private Collection outputFiles = new HashSet();

    /**
     * Initialize the compiler. 
     *
     * @param options Contains jltools options
     */
    public Compiler(Options options_) {
	options = options_;

	// These must be done after the extension is initialized.
	source_loader = options.extension.sourceLoader();
	target_factory = options.extension.targetFactory();

	type_system = options.extension.typeSystem();
	node_factory = options.extension.nodeFactory();

	eq = new ErrorQueue(System.err, options.error_count,
		            options.extension.compilerName());
     
	// Create the compiler and set up the resolvers.
	parsedResolver = new TableResolver();
	loadedResolver = new LoadedClassResolver(this, type_system,
						 options.no_source_check);

	CompoundResolver compoundResolver =
	    new CompoundResolver(parsedResolver, loadedResolver);

	systemResolver = new CachingResolver(compoundResolver);

	/* Other setup. */
	worklist = new LinkedList();
	jobs = new HashMap();

	// This must be done last.
	options.extension.initCompiler(this);
    }

    /** Return a set of output filenames resulting from a compilation. */
    public Collection outputFiles() {
	return outputFiles;
    }

    /**
     * Compile a source file until the types in the source file are
     * constructed.
     */
    public boolean readSource(Source source) throws IOException {
	Job job = jobForSource(source);
	addPass(job.translatePass());
	return runToPass(job.disambTypesPass()); 
    }

    /** Compile the source file for a given class to completion. */
    public boolean readClass(String className) throws IOException {
	Source source = source_loader.classSource(className);
	return readSource(source);
    }

    /** Get a job for the source. */
    public Job jobForSource(Source source) {
	Job job = (Job) jobs.get(source);

	if (job == null) {
	    job = options.extension.createJob(source);
	    jobs.put(source, job);
	}

	return job;
    }

    /** Return a collection of all jobs in the compilation. */
    public Collection jobs() {
	return jobs.values();
    }

    /**
     * Compile all the files listed in the set of strings <code>source</code>.
     * Return true on success. The method <code>outputFiles</code> can be
     * used to obtain the output of the compilation.  This is the main entry
     * point for the compiler, called from main().
     */
    public boolean compile(Collection sources) {
	boolean okay = false;

	try {
	    try {
		for (Iterator i = sources.iterator(); i.hasNext(); ) {
		    String sourceName = (String) i.next();
		    Source source = source_loader.fileSource(sourceName);
		    Job job = jobForSource(source);
		    addPass(job.translatePass());
		}

		okay = finish();
	    }
	    catch (FileNotFoundException e) {
		eq.enqueue(ErrorInfo.IO_ERROR,
		    "Cannot find source file \"" + e.getMessage() + "\".");
	    }
	    catch (IOException e) {
		eq.enqueue(ErrorInfo.IO_ERROR, e.getMessage());
	    }
	    catch (InternalCompilerError e) {
		e.printStackTrace();
		eq.enqueue(ErrorInfo.INTERNAL_ERROR, e.message(), e.position());
	    }
	}
	catch (ErrorLimitError e) {
	}

	eq.flush();
	return okay;
    }

    /** Add a pass to the worklist. */
    public void addPass(Pass pass) {
	if (pass.status() == Pass.NEW) {
	    worklist.add(pass);
	    pass.status(Pass.ENQUEUED);
	    report(2, "Pushing pass " + pass);
	}
    }

    /** Run all passes in the worklist until the <code>goal</code> pass completes. */
    public boolean runToPass(Pass goal) {
	report(1, "Running to pass " + goal);

	LinkedList stack = new LinkedList();

	stack.add(goal);

OUTER:
	while (! stack.isEmpty()) {
	    Pass pass = (Pass) stack.removeLast();

	    report(2, "Trying to run pass " + pass);
	    report(3, "status=" + pass.status());
	    report(3, "deps=" + pass.runAfter());

	    if (pass.status() == Pass.DONE || pass.status() == Pass.FAILED) {
		continue;
	    }

	    // We're currently running.  We can't reach the goal.
	    if (pass.status() == Pass.RUNNING) {
		break;
	    }

	    // Check if any dependencies have failed.
	    for (Iterator i = pass.runAfter().iterator(); i.hasNext(); ) {
		Pass dep = (Pass) i.next();

		if (dep.status() == Pass.FAILED) {
		    report(3, "Dependency " + dep + " of " + pass + " failed.");
		    pass.status(Pass.FAILED);
		    continue OUTER;
		}
	    }

	    // Add this pass back to the stack underneath the dependencies.
	    stack.add(pass);

	    // Push our dependencies.
	    for (Iterator i = pass.runAfter().iterator(); i.hasNext(); ) {
		Pass dep = (Pass) i.next();

		if (dep.status() != Pass.DONE) {
		    stack.add(dep);
		}
	    }

	    // If we're not the top of stack anymore, run a dependency.
	    if (stack.getLast() != pass) {
		report(3, "Pass " + pass + " not ready.  Running deps.");
		continue;
	    }
	    else {
		stack.removeLast();
	    }

	    report(2, "Running pass " + pass);

	    pass.reinit();

	    pass.status(Pass.RUNNING);

	    long start_time = System.currentTimeMillis();

	    if (pass.run()) {
		if (pass.repeat()) {
		    report(3, "Re-running " + pass);
		    pass.status(Pass.NEW);
		    addPass(pass);
		}
		else {
		    pass.status(Pass.DONE);
		}
	    }
	    else {
		pass.status(Pass.FAILED);
	    }

	    report(2, "Finished " + pass + " status=" + pass.status());
	    reportTime(1, "Finished " + pass + " status=" + pass.status() + 
		    " time=" + (System.currentTimeMillis() - start_time));
		    
	}

	report(1, "Pass " + goal + " " + goal.status());

	return goal.status() == Pass.DONE;
    }

    /** Run all jobs in the worklist to completion. */
    protected boolean finish() {
	boolean okay = true;

	while (okay && ! worklist.isEmpty()) {
	    Pass pass = (Pass) worklist.removeFirst();

	    okay &= runToPass(pass);

	    if (pass.status() != Pass.DONE && pass.status() != Pass.FAILED) {
		throw new InternalCompilerError("We didn't finish pass " +
		    pass + ".");
	    }
	}

	report(1, "Finished all passes -- " + (okay ? "okay" : "failed"));

	return okay;
    }

    /** Should fully qualified class names be used in the output? */
    public boolean useFullyQualifiedNames() {
	return options.fully_qualified_names;
    }

    /** Get the compiler's source loader */
    public SourceLoader sourceLoader() {
	return source_loader;
    }

    /** Get the compiler's target factory */
    public TargetFactory targetFactory() {
	return target_factory;
    }

    /** Get the compiler's node extension factory */
    public NodeFactory nodeFactory() {
	return node_factory;
    }

    /** Get the compiler's type system */
    public TypeSystem typeSystem() {
	return type_system;
    }

    /** Get information about the language extension being compiled. */
    public ExtensionInfo extensionInfo() {
	return options.extension;
    }

    /** Get the compiler's system resolver */
    public Resolver systemResolver() {
	return systemResolver;
    }

    /** Get the compiler's parsed-file resolver */
    public LoadedClassResolver loadedResolver() {
	return loadedResolver;
    }

    /** Get the compiler's parsed-file resolver */
    public TableResolver parsedResolver() {
	return parsedResolver;
    }

    /** Maximum number of characters on each line of output */
    public int outputWidth() {
	return options.output_width;
    }

    /** Should class info be serialized into the output? */
    public boolean serializeClassInfo() {
	return options.serialize_type_info;
    }

    /** Get the compiler's error queue. */
    public ErrorQueue errorQueue() {
	return eq;
    }

    private static Collection topics = new ArrayList(1);
    private static Collection timeTopics = new ArrayList(1);
    
    static {
	topics.add("frontend");
	timeTopics.add("time");
    }

    /** Debug reporting for the frontend. */
    public static void report(int level, String msg) {
	Report.report(topics, level, msg);
    }

    /** Reports the time taken by every pass. */
    public static void reportTime(int level, String msg) {
	Report.report(timeTopics, level, msg);
    }

    static {
      // FIXME: if we get an io error (due to too many files open, for example)
      // it will throw an exception. but, we won't be able to do anything with
      // it since the exception handlers will want to load
      // jltools.util.CodeWriter and jltools.util.ErrorInfo to print and
      // enqueue the error; but the classes must be in memory since the io
      // can't open any files; thus, we force the classloader to load the class
      // file.
      try {
	ClassLoader loader = Compiler.class.getClassLoader();
	loader.loadClass("jltools.util.CodeWriter");
	loader.loadClass("jltools.util.ErrorInfo");
      }
      catch (ClassNotFoundException e) {
	throw new InternalCompilerError(e.getMessage());
      }
    }
}
