package jltools.parse;

import java_cup.runtime.*;

import jltools.ast.*;
import jltools.lex.*;
import jltools.types.*;
import jltools.util.*;
import jltools.ext.op.*;

import java.util.*;

/* Java 1.2 parser for CUP.  
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JDK 1.2 Features added:
  strictfp modifier.
  explicit_constructor_invocation ::= ...
        | primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON ;
  field_access ::= ...
        |       name DOT SUPER DOT IDENTIFIER ;
  method_invocation ::= ...
        |       name DOT SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN ;
*/
parser code  {: 
  ErrorQueue eq;
  Lexer lexer;
  TypeSystem ts;

  public Grm( Lexer l, TypeSystem t, ErrorQueue q) {
    this();
    lexer = l;
    ts = t;
    eq = q;
  }
  
  public static Node ln(Node n, Token t) {
    if( n != null && t != null) {
    	Annotate.setLineNumber(n, t.getLineNumber()); 
    }
    return n;
  }
  
  public static Node ln(Node n, Node m) {
    if( n != null && m != null) {
    	Annotate.setLineNumber(n, Annotate.getLineNumber(m)); 
    }
    return n;
  }

  public static TypeNode dim(TypeNode n, int addDims) {
    if(addDims > 0) {
      Type type = n.getType(), newType = new ArrayType( type.getTypeSystem(), 
                                                        type, addDims);
      return n.reconstruct( newType, newType.getTypeString());
    }
    else {
      return n; 
    }
  }

  public static void addAll( List l, Iterator iter)
  {
    while( iter.hasNext()) {
      l.add( iter.next());
    }
  }

  public void syntax_error(java_cup.runtime.Symbol current) {
    if( current.sym == sym.EOF) {
      eq.enqueue( ErrorInfo.SYNTAX_ERROR,
		  "Unexpected end of file.");
    }
    else {
      eq.enqueue( ErrorInfo.SYNTAX_ERROR, 
		  "Syntax error.", 
		  ((Token)current.value).getLineNumber());
    }
  }

  public void report_fatal_error( String message, Object info)
  {
    eq.enqueue( ErrorInfo.SYNTAX_ERROR,
		"Unable to recover from previous errors.");
  }

:};

scan with {: 

  return lexer.nextToken().symbol(); 

:};

terminal Token BOOLEAN; // primitive_type
terminal Token BYTE, SHORT, INT, LONG, CHAR; // integral_type
terminal Token FLOAT, DOUBLE; // floating_point_type
terminal Token LBRACK, RBRACK; // array_type
terminal Identifier IDENTIFIER; // name
terminal Token DOT; // qualified_name
terminal Token SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ; // separators
terminal Token LPAREN, RPAREN, COLON; // more separators
terminal Token PACKAGE; // package_declaration
terminal Token IMPORT; // import_declaration
terminal Token PUBLIC, PROTECTED, PRIVATE; // modifier
terminal Token STATIC; // modifier
terminal Token ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal Token CLASS; // class_declaration
terminal Token EXTENDS; // super
terminal Token IMPLEMENTS; // interfaces
terminal Token VOID; // method_header
terminal Token THROWS; // throws
terminal Token THIS, SUPER; // explicit_constructor_invocation
terminal Token INTERFACE; // interface_declaration
terminal Token IF, ELSE; // if_then_statement, if_then_else_statement
terminal Token SWITCH; // switch_statement
terminal Token CASE, DEFAULT; // switch_label
terminal Token DO, WHILE; // while_statement, do_statement
terminal Token FOR; // for_statement
terminal Token BREAK; // break_statement
terminal Token CONTINUE; // continue_statement
terminal Token RETURN; // return_statement
terminal Token THROW; // throw_statement
terminal Token TRY; // try_statement
terminal Token CATCH; // catch_clause
terminal Token FINALLY; // finally
terminal Token NEW; // class_instance_creation_expression
terminal Token PLUSPLUS; // postincrement_expression
terminal Token MINUSMINUS; // postdecrement_expression
terminal Token PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal Token LSHIFT, RSHIFT, URSHIFT; // shift_expression
terminal Token LT, GT, LTEQ, GTEQ, INSTANCEOF; // relational_expression
terminal Token EQEQ, NOTEQ; // equality_expression
terminal Token AND; // and_expression
terminal Token XOR; // exclusive_or_expression
terminal Token OR;  // inclusive_or_expression
terminal Token ANDAND; // conditional_and_expression
terminal Token OROR; // conditional_or_expression
terminal Token QUESTION; // conditional_expression
terminal Token MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator
terminal Token LSHIFTEQ, RSHIFTEQ, URSHIFTEQ; // assignment_operator
terminal Token ANDEQ, XOREQ, OREQ; // assignment_operator

terminal IntegerLiteral INTEGER_LITERAL;
terminal jltools.lex.DoubleLiteral FLOATING_POINT_LITERAL;
terminal jltools.lex.BooleanLiteral BOOLEAN_LITERAL;
terminal jltools.lex.CharacterLiteral CHARACTER_LITERAL;
terminal jltools.lex.StringLiteral STRING_LITERAL;
terminal jltools.lex.NullLiteral NULL_LITERAL;

// strictfp keyword, new in Java 1.2
terminal Token STRICTFP;

// Reserved but unused:
terminal CONST, GOTO;

// 19.2) The Syntactic Grammar
non terminal SourceFileNode goal;
// 19.3) Lexical Structure
non terminal jltools.ast.Literal literal;
// 19.4) Types, Values, and Variables
non terminal TypeNode type, primitive_type, numeric_type;
non terminal TypeNode integral_type, floating_point_type;
non terminal TypeNode reference_type;
non terminal TypeNode class_or_interface_type;
non terminal TypeNode class_type, interface_type;
non terminal TypeNode array_type;
// 19.5) Names
non terminal AmbiguousNameExpression name, simple_name, qualified_name;
// 19.6) Packages
non terminal SourceFileNode compilation_unit;
non terminal AmbiguousNameExpression package_declaration_opt, package_declaration;
non terminal List import_declarations_opt, import_declarations;
non terminal List type_declarations_opt, type_declarations;
non terminal ImportNode import_declaration;
non terminal ImportNode single_type_import_declaration;
non terminal ImportNode type_import_on_demand_declaration;
non terminal ClassNode type_declaration;
// 19.7) Productions used only in the LALR(1) grammar
non terminal AccessFlags modifiers_opt, modifiers, modifier;
// 19.8.1) Class Declaration
non terminal ClassNode class_declaration;
non terminal TypeNode super, super_opt;
non terminal List interfaces, interfaces_opt, interface_type_list;
non terminal List class_body;
non terminal List class_body_declarations, class_body_declarations_opt;
non terminal class_body_declaration, class_member_declaration;
// 19.8.2) Field Declarations
non terminal FieldNode field_declaration;
non terminal List variable_declarators;
non terminal VariableDeclarationStatement.Declarator variable_declarator;
non terminal VariableDeclarationStatement.Declarator variable_declarator_id;
non terminal Expression variable_initializer;
// 19.8.3) Method Declarations
non terminal MethodNode method_declaration, method_header, method_declarator;
non terminal List formal_parameter_list_opt, formal_parameter_list;
non terminal FormalParameter formal_parameter;
non terminal List throws_opt, throws;
non terminal List class_type_list;
non terminal BlockStatement method_body;
// 19.8.4) Static Initializers
non terminal BlockStatement static_initializer;
// 19.8.5) Constructor Declarations
non terminal MethodNode constructor_declaration, constructor_declarator;
non terminal BlockStatement constructor_body;
non terminal Statement explicit_constructor_invocation;
// 19.9.1) Interface Declarations
non terminal ClassNode interface_declaration;
non terminal List extends_interfaces_opt, extends_interfaces;
non terminal List interface_body;
non terminal List interface_member_declarations_opt, interface_member_declarations;
non terminal ClassMember interface_member_declaration;
non terminal FieldNode constant_declaration;
non terminal MethodNode abstract_method_declaration;
// 19.10) Arrays
non terminal ArrayInitializerExpression array_initializer;
non terminal List variable_initializers;
// 19.11) Blocks and Statements
non terminal BlockStatement block, block_statements_opt, block_statements;
non terminal Statement block_statement;
non terminal VariableDeclarationStatement local_variable_declaration_statement;
non terminal VariableDeclarationStatement local_variable_declaration;
non terminal Statement statement, statement_no_short_if;
non terminal Statement statement_without_trailing_substatement;
non terminal Statement empty_statement;
non terminal LabelledStatement labeled_statement, labeled_statement_no_short_if;
non terminal Statement expression_statement;
non terminal Expression statement_expression;
non terminal IfStatement if_then_statement;
non terminal IfStatement if_then_else_statement, if_then_else_statement_no_short_if;
non terminal SwitchStatement switch_statement;
non terminal List switch_block, switch_block_statement_groups;
non terminal List switch_block_statement_group, switch_labels;
non terminal SwitchStatement.CaseStatement switch_label;
non terminal WhileStatement while_statement, while_statement_no_short_if;
non terminal DoStatement do_statement;
non terminal ForStatement for_statement, for_statement_no_short_if;
non terminal List for_init_opt, for_init;
non terminal List for_update_opt, for_update;
non terminal List statement_expression_list;
non terminal AmbiguousNameExpression identifier_opt;
non terminal BranchStatement break_statement, continue_statement;
non terminal ReturnStatement return_statement;
non terminal ThrowStatement throw_statement;
non terminal SynchronizedStatement synchronized_statement;
non terminal TryStatement try_statement;
non terminal List catches_opt, catches;
non terminal CatchBlock catch_clause;
non terminal BlockStatement finally;
// 19.12) Expressions
non terminal Expression primary, primary_no_new_array;
non terminal NewObjectExpression class_instance_creation_expression;
non terminal List argument_list_opt, argument_list;
non terminal NewArrayExpression array_creation_expression;
non terminal List dim_exprs;
non terminal Expression dim_expr;
non terminal Integer dims_opt, dims;
non terminal FieldExpression field_access;
non terminal MethodExpression method_invocation;
non terminal ArrayIndexExpression array_access;
non terminal Expression postfix_expression;
non terminal UnaryExpression postincrement_expression, postdecrement_expression;
non terminal Expression unary_expression, unary_expression_not_plus_minus;
non terminal UnaryExpression preincrement_expression, predecrement_expression;
non terminal CastExpression cast_expression;
non terminal Expression multiplicative_expression, additive_expression;
non terminal Expression shift_expression, relational_expression, equality_expression;
non terminal Expression and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal Expression conditional_and_expression, conditional_or_expression;
non terminal Expression conditional_expression, assignment_expression;
non terminal Expression assignment;
non terminal Expression left_hand_side;
non terminal Integer assignment_operator;
non terminal Expression expression_opt, expression;
non terminal Expression constant_expression;

start with goal;

// 19.2) The Syntactic Grammar
goal ::=	
					// SourceFileNode
		compilation_unit:a
			{: RESULT = a; :}
	;

// 19.3) Lexical Structure.
literal ::=
					// jltools.ast.Literal
		INTEGER_LITERAL:a	
			{: RESULT = (jltools.ast.Literal)Grm.ln(new IntLiteral(
					a.getValue().intValue()), a); :} 
	|	FLOATING_POINT_LITERAL:a
			{: RESULT = (jltools.ast.Literal)Grm.ln(new 
					jltools.ast.FloatLiteral(
					a.getValue().doubleValue()), a); :}
	|	BOOLEAN_LITERAL:a
			{: RESULT = (jltools.ast.Literal)Grm.ln(new 
					jltools.ast.BooleanLiteral(
					a.getValue().booleanValue()), a); :}
	|	CHARACTER_LITERAL:a
			{: RESULT = (jltools.ast.Literal)Grm.ln(
					new jltools.ast.CharacterLiteral( 
					a.getValue(), a.getEscapedValue())
					, a); :}
	|	STRING_LITERAL:a
			{: RESULT = (jltools.ast.Literal)Grm.ln(
				new jltools.ast.StringLiteral(
				a.getValue()), a); :}
	|	NULL_LITERAL:a
			{: RESULT = (jltools.ast.Literal)Grm.ln(
				new jltools.ast.NullLiteral(), a); :}
	;

// 19.4) Types, Values, and Variables
type	::=
					// TypeNode
		primitive_type:a
			{: RESULT = a; :}
	|	reference_type:a
			{: RESULT = a; :}
	;
primitive_type ::=
					// TypeNode
		numeric_type:a
			{: RESULT = a; :}
	|	BOOLEAN:a
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
				new PrimitiveType(
				parser.ts, PrimitiveType.BOOLEAN)), a); :}
	;
numeric_type::=
					// TypeNode
		integral_type:a
			{: RESULT = a; :}
	|	floating_point_type:a
			{: RESULT = a; :}
	;
integral_type ::=
					// TypeNode
		BYTE:a 
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
					new PrimitiveType(parser.ts, 
					PrimitiveType.BYTE)), a); :}
	|	SHORT:a 
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
					new PrimitiveType(parser.ts, 
					PrimitiveType.SHORT)), a); :}
	|	INT:a 
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
					new PrimitiveType(parser.ts,
					PrimitiveType.INT)), a); :}
	|	LONG:a 
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
					new PrimitiveType(parser.ts, 
					PrimitiveType.LONG)), a); :}
	|	CHAR:a 
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
					new PrimitiveType(parser.ts,
					PrimitiveType.CHAR)), a); :}
	;
floating_point_type ::=
					// TypeNode
		FLOAT:a 
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
					new PrimitiveType(parser.ts, 
					PrimitiveType.FLOAT)), a); :}
	|	DOUBLE:a
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
					new PrimitiveType(parser.ts, 
					PrimitiveType.DOUBLE)), a); :}
	;
reference_type ::=
					// TypeNode
		class_or_interface_type:a
			{: RESULT = a; :}
	|	array_type:a
			{: RESULT = a; :}
	;
class_or_interface_type ::=
					// TypeNode
		name:a
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
				new AmbiguousType(parser.ts, 
				a.getName())),a); :}
	;
class_type ::=
					// TypeNode
		class_or_interface_type:a
			{: RESULT = a; :}
	;
interface_type ::=
					// TypeNode
		class_or_interface_type:a
			{: RESULT = a; :}
	;		
array_type ::=
					// TypeNode
		primitive_type:a dims:b
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
				new ArrayType(parser.ts, a.getType(), 
				b.intValue())), a); :}
	|	name:a dims:b
			{: RESULT = (TypeNode)Grm.ln(new TypeNode(
				new ArrayType(parser.ts, 
				new AmbiguousType(parser.ts, a.getName()),
				b.intValue())), a); :}
	;
// 19.5) Names
name	::=
					// AmbiguousNameExpression
		simple_name:a
			{: RESULT = a; :}
	|	qualified_name:a
			{: RESULT = a; :}
	;
simple_name ::=
					// AmbiguousNameExpression
		IDENTIFIER:a
			{: RESULT = (AmbiguousNameExpression)Grm.ln
				(new AmbiguousNameExpression(
				a.getIdentifier()), a); :}
	;
qualified_name ::=
					// AmbiguousNameExpression
		name:a DOT IDENTIFIER:b
			{: a.getIdentifiers().add(b.getIdentifier()); 
				RESULT = a; :}
	;
// 19.6) Packages
compilation_unit ::=
					// SourceFileNode
		package_declaration_opt:a
		import_declarations_opt:b
		type_declarations_opt:c
			{: RESULT = (SourceFileNode)Grm.ln
				(new SourceFileNode( 
				(a == null ? null : a.getName()),
				b, c), a); :}
		;
package_declaration_opt ::=
					// AmbiguousNameExpression
		package_declaration:a {: RESULT = a; :} | ;
import_declarations_opt ::=
					// List of ImportNode
		import_declarations:a 
			{: RESULT = a; :} 
	|		{: RESULT = new LinkedList(); :}
	;
type_declarations_opt   ::=
					// List of ClassNode
		type_declarations:a 
			{: RESULT = a; :} 
	|	
			{: RESULT = new LinkedList(); :}
	;
import_declarations ::=
					// List of ImportNode
		import_declaration:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	import_declarations:a import_declaration:b
			{: RESULT = a; a.add(b); :}
	;
type_declarations ::=
					// List of ClassNode
		type_declaration:a
			{: List l = new LinkedList(); 
				if( a != null) { l.add(a); } RESULT = l; :}
	|	type_declarations:a type_declaration:b
			{: RESULT = a; if( b != null) { a.add(b); } :}
	;
package_declaration ::=
					// AmbiguousNameExpression
		PACKAGE name:a SEMICOLON
			{: RESULT = a; :}
	;
import_declaration ::=
					// ImportNode
		single_type_import_declaration:a
			{: RESULT = a; :}
	|	type_import_on_demand_declaration:a
			{: RESULT = a; :}
	;
single_type_import_declaration ::=
					// ImportNode
		IMPORT name:a SEMICOLON
			{: RESULT = (ImportNode)Grm.ln
				(new ImportNode(ImportNode.CLASS, 
				a.getName()), a); :}
	;
type_import_on_demand_declaration ::=
					// ImportNode
		IMPORT name:a DOT MULT SEMICOLON
			{: RESULT = (ImportNode)Grm.ln(
				new ImportNode(ImportNode.PACKAGE, 
				a.getName()), a); :}
	;
type_declaration ::=
					// ClassNode
		class_declaration:a
			{: RESULT = a; :}
	|	interface_declaration:a
			{: RESULT = a; :}	
	|	SEMICOLON
			{: RESULT = null; :}
	;

// 19.7) Productions used only in the LALR(1) grammar
modifiers_opt::=
					// AccessFlags
			{: RESULT = new AccessFlags(); :}
	|	modifiers:a
			{: RESULT = a; :}
	;
modifiers ::=
					// AccessFlags
		modifier:a 
			{: RESULT = a; :}
	|	modifiers:a modifier:b
			{: RESULT = a; a.merge(b); :}
	;
modifier ::=
					// AccessFlags
		PUBLIC:a
			{: AccessFlags af = new AccessFlags();
				af.setPublic(true); 
				RESULT = af; :}	
	|	 PROTECTED:a 
			{: AccessFlags af = new AccessFlags();
				af.setProtected(true); 
				RESULT = af; :}	
	|	 PRIVATE:a
			{: AccessFlags af = new AccessFlags();
				af.setPrivate(true); 
				RESULT = af; :}	
	|	 STATIC:a
			{: AccessFlags af = new AccessFlags();
				af.setStatic(true); 
				RESULT = af; :}	
	|	 ABSTRACT:a 
			{: AccessFlags af = new AccessFlags();
				af.setAbstract(true); 
				RESULT = af; :}	
	|	 FINAL:a 
			{: AccessFlags af = new AccessFlags();
				af.setFinal(true); 
				RESULT = af; :}	
	|	 NATIVE:a 
			{: AccessFlags af = new AccessFlags();
				af.setNative(true); 
				RESULT = af; :}	
	|	 SYNCHRONIZED:a
			{: AccessFlags af = new AccessFlags();
				af.setSynchronized(true); 
				RESULT = af; :}	
	|	 TRANSIENT:a 
			{: AccessFlags af = new AccessFlags();
				af.setTransient(true); 
				RESULT = af; :}	
	|	 VOLATILE:a
			{: AccessFlags af = new AccessFlags();
				af.setVolatile(true); 
				RESULT = af; :}	
	|	 STRICTFP:a // note that semantic analysis must check that the
	                 // context of the modifier allows strictfp.
			{: AccessFlags af = new AccessFlags();
				af.setStrictFloatingPoint(true); 
				RESULT = af; :}	
	;
// 19.8) Classes

// 19.8.1) Class Declarations
class_declaration ::=
					// ClassNode
		modifiers_opt:a CLASS:n IDENTIFIER:b super_opt:c 
						interfaces_opt:d class_body:e
			{: RESULT = (ClassNode)Grm.ln(new ClassNode(a,
				b.getIdentifier(), c, d, e), n); :}
	;
super ::=
					// TypeNode
		EXTENDS class_type:a 
			{: RESULT = a; :}		
	;
super_opt ::=
					// TypeNode
	|	super:a
			{: RESULT = a; :}
	;
interfaces ::=
					// List of TypeNode
		IMPLEMENTS interface_type_list:a
			{: RESULT = a; :}
	;
interfaces_opt::=
					// List of TypeNode
			{: RESULT = new LinkedList(); :}
	|	interfaces:a
			{: RESULT = a; :} 
	;
interface_type_list ::=
					// List of TypeNode
		interface_type:a 
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	interface_type_list:a COMMA interface_type:b
			{: RESULT = a; a.add(b); :}
	;
class_body ::=
					// List of ClassMember
		LBRACE class_body_declarations_opt:a RBRACE 
			{: RESULT = a; :}
	;
class_body_declarations_opt ::=
					// List of ClassMember
			{: RESULT = new LinkedList(); :}
	|	class_body_declarations:a
			{: RESULT = a; :}
	;
class_body_declarations ::=
					// List of ClassMember
		class_body_declaration:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	class_body_declarations:a class_body_declaration:b
			{: RESULT = a; a.add(b); :}
	;
class_body_declaration ::=
					// ClassMember
		class_member_declaration:a
			{: RESULT = a; :}
	|	static_initializer:a
			{: RESULT = (ClassMember)Grm.ln(
				new InitializerBlock(a,true), a); :}
	|	constructor_declaration:a
			{: RESULT = a; :}
	|	block:a
			{: RESULT = (ClassMember)Grm.ln
				(new InitializerBlock(a,false), a); :}
	;
class_member_declaration ::=
					// ClassMember
		field_declaration:a
			{: RESULT = a; :}
	|	method_declaration:a
			{: RESULT = a; :}
	/* repeat the prod for 'class_declaration' here: */
	|	modifiers_opt:a CLASS:n IDENTIFIER:b super_opt:c 
						interfaces_opt:d class_body:e
			{: RESULT = (ClassMember)Grm.ln(new ClassNode(
				a, b.getIdentifier(), c, d, e), n); :}
	|	interface_declaration:a
			{: RESULT = a; :}
	;

// 19.8.2) Field Declarations
field_declaration ::=
					// FieldNode
		modifiers_opt:a type:b variable_declarators:c SEMICOLON
			{: RESULT = (FieldNode)Grm.ln(new FieldNode(a, 
				(VariableDeclarationStatement)
				Grm.ln(new VariableDeclarationStatement(a, 
				b, c), b)), b); :}
	;
variable_declarators ::=
					// List of Declarator
		variable_declarator:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	variable_declarators:a COMMA variable_declarator:b
			{: RESULT = a; a.add(b); :}
	;
variable_declarator ::=
				// VariableDeclarationStatement.Declarator
		variable_declarator_id:a
			{: RESULT = a; :}
	|	variable_declarator_id:a EQ variable_initializer:b
			{: RESULT = a; a.initializer = b; :}
	;
variable_declarator_id ::=
				// VariableDeclarationStatement.Declarator
		IDENTIFIER:a
			{: RESULT = new VariableDeclarationStatement.
				Declarator(a.getIdentifier(), 0, null); :}
	|	variable_declarator_id:a LBRACK RBRACK
			{: RESULT = a; a.additionalDimensions++; :}
	;
variable_initializer ::=
					// Expression
		expression:a
			{: RESULT = a; :}
	|	array_initializer:a
			{: RESULT = a; :}
	;

// 19.8.3) Method Declarations
method_declaration ::=
					// MethodNode
		method_header:a method_body:b
			{: List f = new LinkedList(), e = new LinkedList(); 
				Grm.addAll( f, a.formalParameters());
				Grm.addAll( e, a.exceptions());
				RESULT = a.reconstruct( false, 
				a.getAccessFlags(), (TypeNode)
				Grm.ln( new TypeNode( a.getReturnType()), a), 
				a.getName(), f, e, b, 0); :}
	;
method_header ::=
					// MethodNode
		modifiers_opt:a type:b method_declarator:c throws_opt:d
			{: List f = new LinkedList(); 
				Grm.addAll( f, c.formalParameters());
				RESULT = c.reconstruct( false, a, 
				b, c.getName(), f, d,
				c.getBody(), 0); :}
	|	modifiers_opt:a VOID:n method_declarator:c throws_opt:d
			{: List f = new LinkedList(); 
				Grm.addAll( f, c.formalParameters());
				RESULT = c.reconstruct( false, a, 
				(TypeNode)Grm.ln( new TypeNode( 
				parser.ts.getVoid()), n), c.getName(), f, d,
				c.getBody(), 0); :}
	;
method_declarator ::=
					// MethodNode
		IDENTIFIER:a LPAREN formal_parameter_list_opt:b RPAREN
			{: RESULT = (MethodNode)Grm.ln(new MethodNode(
				new AccessFlags(), 
				null, a.getIdentifier(), b, new LinkedList(), 
				new BlockStatement()), a); :}
	|	method_declarator:a LBRACK RBRACK // deprecated
			{: List f = new LinkedList(), e = new LinkedList();
				Grm.addAll( f, a.formalParameters());
				Grm.addAll( e, a.exceptions());
				RESULT = a.reconstruct(false, 
				a.getAccessFlags(),
				(TypeNode)Grm.ln(new TypeNode(
				a.getReturnType()), a), a.getName(), f, e, 
				a.getBody(), 1); :}
	// be careful; the above production also allows 'void foo() []'
	;
formal_parameter_list_opt ::=		
					// List of FormalParameters
			{: RESULT = new LinkedList(); :} 
	|	formal_parameter_list:a
			{: RESULT = a; :}
	;
formal_parameter_list ::=
					// List of FormalParameters
		formal_parameter:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	formal_parameter_list:a COMMA formal_parameter:b
			{: RESULT = a; a.add(b); :}	
	;
formal_parameter ::=
					// FormalParameter
		type:a variable_declarator_id:b
			{: RESULT = (FormalParameter)Grm.ln(
				new FormalParameter(Grm.dim(a,
				b.additionalDimensions), b.name, false), a); :}
	|	FINAL type:a variable_declarator_id:b
			{: RESULT = (FormalParameter)Grm.ln(
				new FormalParameter(Grm.dim(a,
				b.additionalDimensions), b.name, true), a); :}
	;
throws_opt ::=				
					// List of TypeNode
			{: RESULT = new LinkedList(); :}
	|	throws:a
			{: RESULT = a; :}
	;
throws ::=				
					// List of TypeNode
		THROWS class_type_list:a
			{: RESULT = a; :}
	;
class_type_list ::=
					// List of TypeNode
		class_type:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	class_type_list:a COMMA class_type:b
			{: RESULT = a; a.add(b); :}	
	;
method_body ::=
					// BlockStatement
		block:a
			{: RESULT = a; :}
	|	SEMICOLON
			{: RESULT = new BlockStatement(); :}
	;

// 19.8.4) Static Initializers
static_initializer ::=
					// BlockStatement
		STATIC block:a
			{: RESULT = a; :}
	;

// 19.8.5) Constructor Declarations
constructor_declaration ::=
					// MethodNode
		modifiers_opt:a constructor_declarator:b throws_opt:c 
			constructor_body:d
			{: List f = new LinkedList(); Grm.addAll(f, 
				b.formalParameters());
				RESULT = b.reconstruct( true, a, null, null,
				f, c, d, 0); :}
	;
constructor_declarator ::=
					// MethodNode
		simple_name:a LPAREN formal_parameter_list_opt:b RPAREN
			{: RESULT = (MethodNode)Grm.ln(new MethodNode(
				new AccessFlags(),
				b, new LinkedList(), null), a); :}
	;
constructor_body ::=
					// BlockStatement
		LBRACE explicit_constructor_invocation:a
			block_statements:b RBRACE
			{: List l = new LinkedList(); l.add(a);
				Grm.addAll(l, b.statements());
				RESULT = b.reconstruct(l); :}
	|	LBRACE explicit_constructor_invocation:a RBRACE
			{: List l = new LinkedList(); l.add(a);
				BlockStatement b = new BlockStatement( l);
				RESULT = (BlockStatement)Grm.ln(b, a); :}
	|	LBRACE block_statements:a RBRACE
			{: RESULT = a; :}		
	|	LBRACE:a RBRACE
			{: RESULT = (BlockStatement)Grm.ln(
				new BlockStatement(), a); :}
	;
explicit_constructor_invocation ::=
					// Statement
		THIS:a LPAREN argument_list_opt:b RPAREN SEMICOLON
			{: RESULT = (Statement)Grm.ln(
				new ConstructorCallStatement(null,
				ConstructorCallStatement.THIS, b), a); :}
	|	SUPER:a LPAREN argument_list_opt:b RPAREN SEMICOLON
			{: RESULT = (Statement)Grm.ln(
				new ConstructorCallStatement(null,
				ConstructorCallStatement.SUPER, b), a); :}
	|	primary:a DOT THIS LPAREN argument_list_opt:b RPAREN SEMICOLON
			{: RESULT = (Statement)Grm.ln(
				new ConstructorCallStatement(a,
				ConstructorCallStatement.THIS, b), a); :}
	|	primary:a DOT SUPER LPAREN argument_list_opt:b RPAREN SEMICOLON
			{: RESULT = (Statement)Grm.ln(
				new ConstructorCallStatement(a,
				ConstructorCallStatement.SUPER, b), a); :}
	;

// 19.9) Interfaces

// 19.9.1) Interface Declarations
interface_declaration ::=
					// ClassNode
		modifiers_opt:a INTERFACE:n IDENTIFIER:b 
				extends_interfaces_opt:c interface_body:d
			{: RESULT = (ClassNode)Grm.ln(new ClassNode(a,	
				b.getIdentifier(), (TypeNode)null, c, d), n); 
				a.setInterface(true); :}
	;
extends_interfaces_opt ::=
					// List of TypeNode
			{: RESULT = new LinkedList(); :}
	|	extends_interfaces:a
			{: RESULT = a; :}
	;
extends_interfaces ::=
					// List of TypeNode
		EXTENDS interface_type:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	extends_interfaces:a COMMA interface_type:b
			{: RESULT = a; a.add(b); :}	
	;
interface_body ::=
					// List of ClassMember
		LBRACE interface_member_declarations_opt:a RBRACE
			{: RESULT = a; :}
	;
interface_member_declarations_opt ::=
					// List of ClassMember
	|	interface_member_declarations:a
			{: RESULT = a; :}
	;
interface_member_declarations ::=
					// List of ClassMember
		interface_member_declaration:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}		
	|	interface_member_declarations:a interface_member_declaration:b
			{: RESULT = a; a.add(b); :}
	;
interface_member_declaration ::=
					// ClassMember
		constant_declaration:a
			{: RESULT = a; :}
	|	abstract_method_declaration:a
			{: RESULT = a; :}
	|	class_declaration:a 
			{: RESULT = a; :}
	|	interface_declaration:a
			{: RESULT = a; :}
	;
constant_declaration ::=
					// FieldNode
		field_declaration:a
			{: RESULT = a; :}
	// need to semantically check that modifiers of field declaration
	// include only PUBLIC, STATIC, or FINAL.  Other modifiers are
	// disallowed.
	;
abstract_method_declaration ::=
					// MethodNode
		method_header:a SEMICOLON
			{: RESULT = a; :}
	;

// 19.10) Arrays
array_initializer ::=
					// ArrayInitializerExpression
		LBRACE:n variable_initializers:a COMMA RBRACE
			{: RESULT = (ArrayInitializerExpression)
			       Grm.ln(new ArrayInitializerExpression(a), n); :}
	|	LBRACE:n variable_initializers:a RBRACE
			{: RESULT = (ArrayInitializerExpression)
			       Grm.ln(new ArrayInitializerExpression(a), n); :}
	|	LBRACE:a COMMA RBRACE
			{: RESULT = (ArrayInitializerExpression)
				Grm.ln(new ArrayInitializerExpression(), a); :}
	|	LBRACE:a RBRACE
			{: RESULT = (ArrayInitializerExpression)
				Grm.ln(new ArrayInitializerExpression(), a); :}
	;
variable_initializers ::=
					// List of Expression
		variable_initializer:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	variable_initializers:a COMMA variable_initializer:b
			{: RESULT = a; a.add(b); :}	
	;

// 19.11) Blocks and Statements
block ::=
					// BlockStatement
		LBRACE block_statements_opt:a RBRACE
			{: RESULT = a; :}
	;
block_statements_opt ::=
					// BlockStatement
			{: RESULT = new BlockStatement(); :}
	|	block_statements:a
			{: RESULT = a; :}
	;
block_statements ::=
					// BlockStatement
		block_statement:a
			{: List l = new LinkedList(); l.add(a);
				BlockStatement b = new BlockStatement(l);
				RESULT = (BlockStatement)Grm.ln(b,a); :}
	|	block_statements:a block_statement:b
			{: RESULT = a.appendStatement(b); :}
	;
block_statement ::=
					// Statement
		local_variable_declaration_statement:a
			{: RESULT = a; :}
	|	statement:a
			{: RESULT = a; :}
	|	class_declaration:a
			{: RESULT = (Statement)Grm.ln(
				new ClassDeclarationStatement(a), a); :}
	|	interface_declaration:a
			{: RESULT = (Statement)Grm.ln(
				new ClassDeclarationStatement(a), a); :}
	;
local_variable_declaration_statement ::=
					// VariableDeclarationStatement
		local_variable_declaration:a SEMICOLON
			{: RESULT = a; :}
	;
local_variable_declaration ::=
					// VariableDeclarationStatement
		type:a variable_declarators:b
			{: RESULT = (VariableDeclarationStatement)Grm.ln(
				new VariableDeclarationStatement(
				new AccessFlags(), a, b), a); :}
	|	FINAL type:a variable_declarators:b
		      {: AccessFlags af = new AccessFlags(); af.setFinal(true);
				RESULT = (VariableDeclarationStatement)Grm.ln(
				new VariableDeclarationStatement(
				af, a, b), a); :}
	;
statement ::=
					// Statement
		statement_without_trailing_substatement:a
			{: RESULT = a; :}
	|	labeled_statement:a
			{: RESULT = a; :}
	|	if_then_statement:a
			{: RESULT = a; :}
	|	if_then_else_statement:a
			{: RESULT = a; :}
	|	while_statement:a
			{: RESULT = a; :}
	|	for_statement:a
			{: RESULT = a; :}
	;
statement_no_short_if ::=
					// Statement
		statement_without_trailing_substatement:a
			{: RESULT = a; :}
	|	labeled_statement_no_short_if:a
			{: RESULT = a; :}
	|	if_then_else_statement_no_short_if:a
			{: RESULT = a; :}
	|	while_statement_no_short_if:a
			{: RESULT = a; :}
	|	for_statement_no_short_if:a
			{: RESULT = a; :}
	;
statement_without_trailing_substatement ::=
					// Statement 
		block:a
			{: RESULT = a; :}
	|	empty_statement:a
			{: RESULT = a; :}
	|	expression_statement:a
			{: RESULT = a; :}
	|	switch_statement:a
			{: RESULT = a; :}
	|	do_statement:a
			{: RESULT = a; :}
	|	break_statement:a
			{: RESULT = a; :}
	|	continue_statement:a
			{: RESULT = a; :}
	|	return_statement:a
			{: RESULT = a; :}
	|	synchronized_statement:a
			{: RESULT = a; :}
	|	throw_statement:a
			{: RESULT = a; :}
	|	try_statement:a
			{: RESULT = a; :}
	;
empty_statement ::=
					// Statement
		SEMICOLON
	;
labeled_statement ::=
					// LabelledStatement
		IDENTIFIER:a COLON statement:b
			{: RESULT = (LabelledStatement)Grm.ln(
				new LabelledStatement(
				a.getIdentifier(), b), a); :}
	;
labeled_statement_no_short_if ::=
					// LabelledStatement
		IDENTIFIER:a COLON statement_no_short_if:b
			{: RESULT = (LabelledStatement)Grm.ln(
				new LabelledStatement(
				a.getIdentifier(), b), a); :}
	;
expression_statement ::=
					// Statement
		statement_expression:a SEMICOLON
			{: RESULT = (Statement)Grm.ln(
				new ExpressionStatement(a), a); :}
	;
statement_expression ::=
					// Expression
		assignment:a
			{: RESULT = a; :}
	|	preincrement_expression:a
			{: RESULT = a; :}
	|	predecrement_expression:a
			{: RESULT = a; :}
	|	postincrement_expression:a
			{: RESULT = a; :}
	|	postdecrement_expression:a
			{: RESULT = a; :}
	|	method_invocation:a
			{: RESULT = a; :}
	|	class_instance_creation_expression:a
			{: RESULT = a; :}
	;
if_then_statement ::=
					// IfStatement
		IF LPAREN expression:a RPAREN statement:b
			{: RESULT = (IfStatement)Grm.ln(
				new IfStatement(a, b), a); :}
	;
if_then_else_statement ::=
					// IfStatement
		IF LPAREN expression:a RPAREN statement_no_short_if:b 
			ELSE statement:c
			{: RESULT = (IfStatement)Grm.ln(
				new IfStatement(a, b, c), a); :}
	;
if_then_else_statement_no_short_if ::=
					// IfStatement
		IF LPAREN expression:a RPAREN statement_no_short_if:b
			ELSE statement_no_short_if:c
			{: RESULT = (IfStatement)Grm.ln(
				new IfStatement(a, b, c), a); :}
	;
switch_statement ::=
					// SwitchStatement
		SWITCH LPAREN expression:a RPAREN switch_block:b
			{: RESULT = (SwitchStatement)Grm.ln(
				new SwitchStatement(a, b), a); :}
	;
switch_block ::=
					// List of SwitchElement
		LBRACE switch_block_statement_groups:a switch_labels:b RBRACE
			{: RESULT = a; a.addAll(b); :}
	|	LBRACE switch_block_statement_groups:a RBRACE
			{: RESULT = a; :}
	|	LBRACE switch_labels:a RBRACE
			{: RESULT = a; :}
	|	LBRACE RBRACE
			{: RESULT = new LinkedList(); :}
	;
switch_block_statement_groups ::=
					// List of SwitchElement
		switch_block_statement_group:a
			{: RESULT = a; :}		
	|	switch_block_statement_groups:a switch_block_statement_group:b
			{: RESULT = a; a.addAll(b); :}
	;
switch_block_statement_group ::=
					// List of SwitchElement
		switch_labels:a block_statements:b
			{: List l = new LinkedList(); RESULT = l; l.addAll(a); 
				l.add(new SwitchStatement.SwitchBlock(b)); :}
	;
switch_labels ::=
					// List of CaseStatement
		switch_label:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	switch_labels:a switch_label:b
			{: RESULT = a; a.add(b); :}
	;
switch_label ::=
					// SwitchStatement.CaseStatement
		CASE:n constant_expression:a COLON
			{: RESULT = (SwitchStatement.CaseStatement)Grm.ln( 
 				new SwitchStatement.CaseStatement(a), n); :}
	|	DEFAULT:n COLON
			{: RESULT = (SwitchStatement.CaseStatement)Grm.ln( 
 				new SwitchStatement.CaseStatement(), n); :}
	;

while_statement ::=
					// WhileStatement
		WHILE:n LPAREN expression:a RPAREN statement:b
			{: RESULT = (WhileStatement)Grm.ln(
				new WhileStatement( a, b), n); :}
	;
while_statement_no_short_if ::=
					// WhileStatement
		WHILE:n LPAREN expression:a RPAREN statement_no_short_if:b
			{: RESULT = (WhileStatement)Grm.ln(
				new WhileStatement( a, b), n); :}
	;
do_statement ::=			
					// DoStatement
		DO:n statement:a WHILE LPAREN expression:b RPAREN SEMICOLON
			{: RESULT = (DoStatement)Grm.ln(
				new DoStatement(a, b), n); :}
	;
for_statement ::=
					// ForStatement 
	       FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON
			for_update_opt:c RPAREN statement:d
			{: RESULT = (ForStatement)Grm.ln(
				new ForStatement(a, b, c, d), n); :}
	;
for_statement_no_short_if ::=
					// ForStatement
	       FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON
			for_update_opt:c RPAREN statement_no_short_if:d
			{: RESULT = (ForStatement)Grm.ln(
				new ForStatement(a, b, c, d), n); :}
	;
for_init_opt ::=
					// List of Statement
			{: RESULT = new LinkedList(); :}
	|	for_init:a
			{: RESULT = a; :}
	;
for_init ::=
					// List of Statement
		statement_expression_list:a
			{: RESULT = a; :}
	|	local_variable_declaration:a
			{: List l = new LinkedList(); l.add(a);
				RESULT = l; :}
	;
for_update_opt ::=
					// List of Statement
			{: RESULT = new LinkedList(); :}
	|	for_update:a
			{: RESULT = a; :}
	;
for_update ::=
					// List of Statement
		statement_expression_list:a
			{: RESULT = a; :}
	;
statement_expression_list ::=
					// List of Statement
		statement_expression:a
			{: List l = new LinkedList(); l.add(Grm.ln(
			new ExpressionStatement(a), a)); RESULT = l; :}
	|	statement_expression_list:a COMMA statement_expression:b
			{: RESULT = a; a.add(Grm.ln(new ExpressionStatement(
			b), b)); :}
	;

identifier_opt ::=
					// AmbiguousNameExpression
	|	IDENTIFIER:a
			{: RESULT = (AmbiguousNameExpression)Grm.ln(
				new AmbiguousNameExpression(
				a.getIdentifier()), a); :}
	;

break_statement ::=
					// BranchStatement
		BREAK identifier_opt:a SEMICOLON
			{: RESULT = (BranchStatement)Grm.ln(
				new BranchStatement(
				BranchStatement.BREAK, 
				(a == null ? null : a.getName())), a); :}
				// FIXME
	;

continue_statement ::=
					// BranchStatement
		CONTINUE identifier_opt:a SEMICOLON
			{: RESULT = (BranchStatement)Grm.ln(
				new BranchStatement(
				BranchStatement.CONTINUE,
				(a == null ? null : a.getName())), a); :}
				// FIXME

	;
return_statement ::=
					// ReturnStatement
		RETURN expression_opt:a SEMICOLON
			{: RESULT = (ReturnStatement)Grm.ln(
				new ReturnStatement(a), a); :}
	;
throw_statement ::=
					// ThrowStatement
		THROW expression:a SEMICOLON
			{: RESULT = (ThrowStatement)Grm.ln(
				new ThrowStatement(a), a); :}
	;
synchronized_statement ::=
					// SynchronizedStatement
		SYNCHRONIZED LPAREN expression:a RPAREN block:b
			{: RESULT = (SynchronizedStatement)Grm.ln(
				new SynchronizedStatement(a, b), a); :}
	;
try_statement ::=
					// TryStatement
		TRY block:a catches:b
			{: RESULT = (TryStatement)Grm.ln(
				new TryStatement(a, b, null), a); :}
	|	TRY block:a catches_opt:b finally:c
			{: RESULT = (TryStatement)Grm.ln(
				new TryStatement(a, b, c), a); :}
	;
catches_opt ::=
					// List of CatchBlock
			{: RESULT = new LinkedList(); :}
	|	catches:a
			{: RESULT = a; :}
	;
catches ::=
					// List of CatchBlock
		catch_clause:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	catches:a catch_clause:b
			{: RESULT = a; a.add(b); :}
	;
catch_clause ::=
					// CatchBlock
		CATCH LPAREN formal_parameter:a RPAREN block:b
			{: RESULT = (CatchBlock)Grm.ln(
				new CatchBlock(a, b), a); :}
	;
finally ::=
					// BlockStatement
		FINALLY block:a
			{: RESULT = a; :}
	;

// 19.12) Expressions			// Expression
primary ::=
					primary_no_new_array:a
			{: RESULT = a; :}
	|	array_creation_expression:a
			{: RESULT = a; :}
	;
primary_no_new_array ::=
					// Expression
		literal:a
			{: RESULT = a; :}
	|	THIS:a
			{: RESULT = (Expression)Grm.ln(
				new SpecialExpression((TypeNode)null,
				SpecialExpression.THIS), a); :}
	|	LPAREN expression:a RPAREN
			{: RESULT = a; :}
	|	class_instance_creation_expression:a
			{: RESULT = a; :}
	|	field_access:a
			{: RESULT = a; :}
	|	method_invocation:a
			{: RESULT = a; :}
	|	array_access:a
			{: RESULT = a; :}
	|	primitive_type:a DOT CLASS
			{: RESULT = (Expression)Grm.ln(
				new FieldExpression((TypeNode)Grm.ln(
				new TypeNode(a.getType()), a), "class"), a); :}
	|	VOID:a DOT CLASS
			{: RESULT = (Expression)Grm.ln(new FieldExpression( 
			       Grm.ln(new TypeNode(new PrimitiveType(parser.ts,
			       PrimitiveType.VOID)), a), "class"), a); :}

	|	array_type:a DOT CLASS
			{: RESULT = (Expression)Grm.ln(
				new FieldExpression(a, "class"), a); :}
	|	name:a DOT CLASS
			{: RESULT = (Expression)Grm.ln(
				new FieldExpression(a, "class"), a); :}
	|	name:a DOT THIS
			{: RESULT = (Expression)Grm.ln(
				new SpecialExpression((TypeNode)Grm.ln(
				new TypeNode(new AmbiguousType(parser.ts, 
				a.getName())), a), 
				SpecialExpression.THIS), a); :}
	;
class_instance_creation_expression ::=
					// NewObjectExpression
		NEW class_type:a LPAREN argument_list_opt:b RPAREN
			{: RESULT = (NewObjectExpression)Grm.ln(
				new NewObjectExpression(null, 
				a, b, null), a); :}
	|	NEW class_type:a LPAREN argument_list_opt:b RPAREN class_body:c
			{: List l = new LinkedList(); l.add(a);
				RESULT = (NewObjectExpression)Grm.ln(
				new NewObjectExpression(null, a, b, 
				(ClassNode)Grm.ln(new ClassNode(
				new AccessFlags(), "$Anonymous$", 
				(TypeNode)null, l, c), a)), a); :}
	|	primary:a DOT NEW IDENTIFIER:b
			LPAREN argument_list_opt:c RPAREN
			{: RESULT = (NewObjectExpression)Grm.ln(
				new NewObjectExpression(a, (TypeNode)
				Grm.ln(new TypeNode(new AmbiguousType(
				parser.ts, b.getIdentifier())), b), 
				c, null), a); :}
	|	primary:a DOT NEW IDENTIFIER:b
			LPAREN argument_list_opt:c RPAREN class_body:d
			{: TypeNode t = (TypeNode)Grm.ln(new TypeNode(
				new AmbiguousType(parser.ts,
				b.getIdentifier())), b); 
				List l = new LinkedList(); l.add(t); 
				RESULT = (NewObjectExpression)Grm.ln(
				new NewObjectExpression(a, t, c,
				(ClassNode)Grm.ln(new ClassNode( 
				new AccessFlags(), "$Anonymous$", 
				(TypeNode)null, l, null), a)), a); :}
	;
argument_list_opt ::=
					// List of Expression
			{: RESULT = new LinkedList(); :}
	|	argument_list:a
			{: RESULT = a; :}
	;
argument_list ::=
					// List of Exprssion
		expression:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	argument_list:a COMMA expression:b
			{: RESULT = a; a.add(b); :}
	;
array_creation_expression ::=
					// NewArrayExpression
		NEW primitive_type:a dim_exprs:b dims_opt:c
			{: RESULT = (NewArrayExpression)Grm.ln(
				new NewArrayExpression(a, b,
				c.intValue(), null), a); :}
	|	NEW class_or_interface_type:a dim_exprs:b dims_opt:c
			{: RESULT = (NewArrayExpression)Grm.ln(
				new NewArrayExpression(a, b,
				c.intValue(), null), a); :}
	|	NEW primitive_type:a dims:b array_initializer:c
			{: RESULT = (NewArrayExpression)Grm.ln(
				new NewArrayExpression(a, new LinkedList(),
				b.intValue(), c), a); :}
	|	NEW class_or_interface_type:a dims:b array_initializer:c
			{: RESULT = (NewArrayExpression)Grm.ln(
				new NewArrayExpression(a, new LinkedList(),
				b.intValue(), c), a); :}
	;
dim_exprs ::=
					// List of Expression
		dim_expr:a
			{: List l = new LinkedList(); l.add(a); RESULT = l; :}
	|	dim_exprs:a dim_expr:b
			{: RESULT = a; a.add(b); :}
	;
dim_expr ::=
					// Expression
		LBRACK expression:a RBRACK
			{: RESULT = a; :}
	;
dims_opt ::=
					// Integer
			{: RESULT = new Integer(0); :}
	|	dims:a
			{: RESULT = a; :}
	;
dims ::=
					// Integer
		LBRACK RBRACK
			{: RESULT = new Integer(1); :}
	|	dims:a LBRACK RBRACK
			{: RESULT = new Integer(a.intValue() + 1); :}
	;
field_access ::=
					// FieldExpression
		primary:a DOT IDENTIFIER:b
			{: RESULT = (FieldExpression)Grm.ln(
				new FieldExpression(a, 
				b.getIdentifier()), a); :}
	|	SUPER:n DOT IDENTIFIER:a
			{: RESULT = (FieldExpression)Grm.ln(
				new FieldExpression(
				(SpecialExpression)Grm.ln(
				new SpecialExpression((TypeNode)null,
				SpecialExpression.SUPER), n), 
				a.getIdentifier()), a); :}
	|	name:a DOT SUPER DOT IDENTIFIER:b
			{: RESULT = (FieldExpression)Grm.ln(
				new FieldExpression(
				a.reconstruct(a.getName() + ".super"),
				b.getIdentifier()), a); :}
	;
method_invocation ::=
					// MethodExpression
		name:a LPAREN argument_list_opt:b RPAREN
			{: RESULT = (MethodExpression)Grm.ln(
				new MethodExpression(null, a.getName(), b), 
				a); :}
	|	primary:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN
			{: RESULT = (MethodExpression)Grm.ln(
				new MethodExpression(a, b.getIdentifier(), c),
				a); :}
	|	SUPER:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN
			{: RESULT = (MethodExpression)Grm.ln(
				new MethodExpression((Expression)Grm.ln(
				new SpecialExpression((TypeNode)null, 
				SpecialExpression.SUPER), a),
				b.getIdentifier(), c), a); :}	
	|	name:a DOT SUPER DOT IDENTIFIER:b 
				LPAREN argument_list_opt:c RPAREN
			{: RESULT = (MethodExpression)Grm.ln(
				new MethodExpression(a, b.getIdentifier(), c),
				a); :}	
	;
array_access ::=
					// ArrayIndexExpression
		name:a LBRACK expression:b RBRACK
			{: RESULT = (ArrayIndexExpression)Grm.ln(
				new ArrayIndexExpression(a, b), a); :}
	|	primary_no_new_array:a LBRACK expression:b RBRACK
			{: RESULT = (ArrayIndexExpression)Grm.ln(
				new ArrayIndexExpression(a, b), a); :}
	;
postfix_expression ::=
					// Expression
		primary:a
			{: RESULT = a; :}
	|	name:a
			{: RESULT = a; :}
	|	postincrement_expression:a
			{: RESULT = a; :}
	|	postdecrement_expression:a
			{: RESULT = a; :}
	;
postincrement_expression ::=
					// UnaryExpression
		postfix_expression:a PLUSPLUS
			{: RESULT = (UnaryExpression)Grm.ln(
				new UnaryExpression(a, 
				UnaryExpression.POSTINCR), a); :}
	;	
postdecrement_expression ::=
					// UnaryExpression
		postfix_expression:a MINUSMINUS
			{: RESULT = (UnaryExpression)Grm.ln(
				new UnaryExpression(a, 
				UnaryExpression.POSTDECR), a); :}
	;
unary_expression ::=
					// Expression
		preincrement_expression:a
			{: RESULT = a; :}
	|	predecrement_expression:a
			{: RESULT = a; :}
	|	PLUS unary_expression:a
			{: RESULT = (Expression)Grm.ln(
				new UnaryExpression(a, 
				UnaryExpression.POSITIVE), a); :}
	|	MINUS unary_expression:a
			{: RESULT = (Expression)Grm.ln(
				new UnaryExpression(a, 
				UnaryExpression.NEGATIVE), a); :}
	|	unary_expression_not_plus_minus:a
			{: RESULT = a; :}
	;
preincrement_expression ::=
					// UnaryExpression
		PLUSPLUS unary_expression:a
			{: RESULT = (UnaryExpression)Grm.ln(
				new UnaryExpression(a, 
				UnaryExpression.PREINCR), a); :}
	;
predecrement_expression ::=
					// UnaryExpression
		MINUSMINUS unary_expression:a
			{: RESULT = (UnaryExpression)Grm.ln(
				new UnaryExpression(a, 
				UnaryExpression.PREDECR), a); :}
	;
unary_expression_not_plus_minus ::=
					// Expression
		postfix_expression:a
			{: RESULT = a; :}
	|	COMP unary_expression:a
			{: RESULT = (Expression)Grm.ln(
				new UnaryExpression(a, 
				UnaryExpression.BITCOMP), a); :}
	|	NOT unary_expression:a
			{: RESULT = (Expression)Grm.ln(
				new UnaryExpression(a, 
				UnaryExpression.LOGICALNOT), a); :}
	|	cast_expression:a
			{: RESULT = a; :}
	;
cast_expression ::=
					// CastExpression
		LPAREN primitive_type:a dims_opt:b RPAREN unary_expression:c
			{: TypeNode tn = (TypeNode)Grm.ln( new TypeNode( 
			        (b.intValue() == 0 ? a.getType() :
			new ArrayType(parser.ts,a.getType(),b.intValue()))),a);
				RESULT = (ObjectPrimitiveCastExpression)Grm.ln(
				new ObjectPrimitiveCastExpression( tn, c), a);
				:}
	|	LPAREN expression:a RPAREN 
				unary_expression_not_plus_minus:b
			{: RESULT = (ObjectPrimitiveCastExpression)Grm.ln(
				new ObjectPrimitiveCastExpression( (TypeNode)
				Grm.ln(new TypeNode( 
				new AmbiguousType( parser.ts, 
				((AmbiguousNameExpression)a).getName())), a),
				b), a); :}
	|	LPAREN name:a dims:b RPAREN unary_expression_not_plus_minus:c
			{: Type t2 = new ArrayType(parser.ts, 
				new AmbiguousType(parser.ts, 
				a.getName()), b.intValue());
				RESULT = (ObjectPrimitiveCastExpression)Grm.ln(
			       new ObjectPrimitiveCastExpression( new TypeNode(t2), c), a); :}
	;
multiplicative_expression ::=
					// Expression
		unary_expression:a
			{: RESULT = a; :}
	|	multiplicative_expression:a MULT unary_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.MULT, b), a); :}
	|	multiplicative_expression:a DIV unary_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.DIV, b), a); :}
	|	multiplicative_expression:a MOD unary_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.MOD, b), a); :}
	;
additive_expression ::=
					// Expression
		multiplicative_expression:a
			{: RESULT = a; :}
	|	additive_expression:a PLUS multiplicative_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.PLUS, b), a); :}
	|	additive_expression:a MINUS multiplicative_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.SUB, b), a); :}
	;
shift_expression ::=
					// Expression
		additive_expression:a
			{: RESULT = a; :}
	|	shift_expression:a LSHIFT additive_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.LSHIFT, b), a); :}
	|	shift_expression:a RSHIFT additive_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.RSHIFT, b), a); :}
	|	shift_expression:a URSHIFT additive_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.RUSHIFT, b), a); :}
	;
relational_expression ::=
					// Expression
		shift_expression:a
			{: RESULT = a; :}
	|	relational_expression:a LT shift_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.LT, b), a); :}
	|	relational_expression:a GT shift_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.GT, b), a); :}
	|	relational_expression:a LTEQ shift_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.LE, b), a); :}
	|	relational_expression:a GTEQ shift_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.GE, b), a); :}
	|	relational_expression:a INSTANCEOF type:b
			{: RESULT = (Expression)Grm.ln(
				new ObjectPrimitiveInstanceofExpression(a,
				b), a); :}
	;

/*
	|	relational_expression:a INSTANCEOF reference_type:b
			{: RESULT = (Expression)Grm.ln(
				new InstanceofExpression(a,
				b), a); :}
*/
	
equality_expression ::=
					// Expression
		relational_expression:a
			{: RESULT = a; :}
	|	equality_expression:a EQEQ relational_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.EQUAL, b), a); :}
	|	equality_expression:a NOTEQ relational_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.NE, b), a); :}
	;
and_expression ::=
					// Expression	
		equality_expression:a
			{: RESULT = a; :}
	|	and_expression:a AND equality_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.BIT_AND, b), a); :}
	;
exclusive_or_expression ::=
					// Expression
		and_expression:a
			{: RESULT = a; :}
	|	exclusive_or_expression:a XOR and_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.BIT_XOR, b), a); :}
	;
inclusive_or_expression ::=
					// Expression
		exclusive_or_expression:a
			{: RESULT = a; :}
	|	inclusive_or_expression:a OR exclusive_or_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a, 
				BinaryExpression.BIT_OR, b), a); :}
	;
conditional_and_expression ::=
					// Expression
		inclusive_or_expression:a
			{: RESULT = a; :}
	|	conditional_and_expression:a ANDAND inclusive_or_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a,
				BinaryExpression.LOGIC_AND, b), a); :}
	;
conditional_or_expression ::=
					// Expression
		conditional_and_expression:a
			{: RESULT = a; :}
	|	conditional_or_expression:a OROR conditional_and_expression:b
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a, 
				BinaryExpression.LOGIC_OR, b), a); :}
	;
conditional_expression ::=
					// Expression
		conditional_or_expression:a
			{: RESULT = a; :}
	|	conditional_or_expression:a QUESTION expression:b 
			COLON conditional_expression:c
			{: RESULT = (Expression)Grm.ln(
				new TernaryExpression(a, b, c), a); :}
	;
assignment_expression ::=
					// Expression
		conditional_expression:a
			{: RESULT = a; :}
	|	assignment:a
			{: RESULT = a; :}
	;
assignment ::=
					// Expression
		left_hand_side:a assignment_operator:b assignment_expression:c
			{: RESULT = (Expression)Grm.ln(
				new BinaryExpression(a, b.intValue(), 
				c), a); :}
	;
left_hand_side ::=
					// Expression
		name:a
			{: RESULT = a; :}
	|	field_access:a
			{: RESULT = a; :}
	|	array_access:a
			{: RESULT = a; :}
	;
assignment_operator ::=
					// Integer
		EQ
			{: RESULT = new Integer(BinaryExpression.ASSIGN); :}
	|	MULTEQ
		       {: RESULT = new Integer(BinaryExpression.MULTASSIGN); :}
	|	DIVEQ
			{: RESULT = new Integer(BinaryExpression.DIVASSIGN); :}
	|	MODEQ
			{: RESULT = new Integer(BinaryExpression.MODASSIGN); :}
	|	PLUSEQ
		       {: RESULT = new Integer(BinaryExpression.PLUSASSIGN); :}
	|	MINUSEQ
			{: RESULT = new Integer(BinaryExpression.SUBASSIGN); :}
	|	LSHIFTEQ
		     {: RESULT = new Integer(BinaryExpression.LSHIFTASSIGN); :}
	|	RSHIFTEQ
		     {: RESULT = new Integer(BinaryExpression.RSHIFTASSIGN); :}
	|	URSHIFTEQ
		    {: RESULT = new Integer(BinaryExpression.RUSHIFTASSIGN); :}
	|	ANDEQ
			{: RESULT = new Integer(BinaryExpression.ANDASSIGN); :}
	|	XOREQ
			{: RESULT = new Integer(BinaryExpression.XORASSIGN); :}
	|	OREQ
			{: RESULT = new Integer(BinaryExpression.ORASSIGN); :}
	;
expression_opt ::=
					// Expression
	|	expression:a
			{: RESULT = a; :}
	;
expression ::=
					// Expression
		assignment_expression:a
			{: RESULT = a; :}
	;
constant_expression ::=
					// Expression
		expression:a
			{: RESULT = a; :}
	;
