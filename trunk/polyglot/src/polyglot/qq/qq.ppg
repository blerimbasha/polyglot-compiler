include "../parse/java12.cup"

package polyglot.ext.jl.qq;

import polyglot.ext.jl.parse.Name;
import polyglot.lex.Lexer;

parser Grm extends polyglot.ext.jl.parse.Grm {:
    public final Map subst;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, Map subst) {
	super(l, t, n, (ErrorQueue)null);
	this.subst = subst;
    }

  /**
   * Override the default CUP routine.
   */
  public void syntax_error (java_cup.runtime.Symbol current)
  {
    Position p = ((Token) current.value).getPosition ();
    System.out.println("p = " + p);
    if (current.sym == sym.EOF)
	report_error ("Unexpected end of file.", p);
    else
	report_error ("Syntax error.", p);
  }
:};

terminal Token COMMA_EXPR;
terminal Token COMMA_STMT;
terminal Token COMMA_TYPE;
terminal Token COMMA_DECL;
terminal Token COMMA_MEMB;
terminal Token COMMA_LIST;

non terminal Node qq_expr;
non terminal Node qq_stmt;
non terminal Node qq_type;
non terminal Node qq_decl;
non terminal Node qq_file;
non terminal Node qq_member;

/* The 1st name is the non terminal; the 2nd is the name of the parse method. */
start with qq_expr qq_expr;
start with qq_stmt qq_stmt;
start with qq_type qq_type;
start with qq_decl qq_decl;
start with qq_file qq_file;
start with qq_member qq_member;

drop { goal }

qq_expr ::=
	expression:a
	    {: RESULT = a; :}
    ;

qq_stmt ::=
    	statement:a
     	    {: RESULT = a; :}
    ;

qq_type ::=
    	type:a
     	    {: RESULT = a; :}
    ;

qq_decl ::=
    	type_declaration:a
     	    {: RESULT = a; :}
    ;

qq_file ::=
    	compilation_unit:a
	    {: RESULT = a; :}
    ;

qq_member ::=
     	method_declaration:a
     	    {: RESULT = a; :}
     /* Simplified version of field_declaration with only one declarator. */
    |	modifiers_opt:a type:b variable_declarator:d SEMICOLON
	    {: RESULT = parser.nf.FieldDecl(parser.pos(b),
					    a, parser.array(b, d.dims),
					    d.name, d.init); :}
    ;

extend primary_no_new_array ::=
	COMMA_EXPR IDENTIFIER:a
	    {: RESULT = (Expr) parser.subst.get(a.getIdentifier()); :}
    ;

extend statement_expression ::=
	COMMA_EXPR IDENTIFIER:a
	    {: RESULT = (Expr) parser.subst.get(a.getIdentifier()); :}
    ;

extend cast_expression ::=
        // Cast
        LPAREN COMMA_TYPE IDENTIFIER:a RPAREN unary_expression:b
            {: RESULT = parser.nf.Cast(parser.pos(a),
                                       (TypeNode) parser.subst.get(a.getIdentifier()), b);
            :}
    ;

extend statement ::=
	COMMA_STMT IDENTIFIER:a
	    {: RESULT = (Stmt) parser.subst.get(a.getIdentifier()); :}
    ;

extend class_or_interface_type ::=
	COMMA_TYPE IDENTIFIER:a
	    {: RESULT = (TypeNode) parser.subst.get(a.getIdentifier()); :}
    ;

extend array_type ::=
	COMMA_TYPE IDENTIFIER:a dims:b
	    {: TypeNode tn = (TypeNode) parser.subst.get(a.getIdentifier());
	       RESULT = parser.array(tn, b.intValue()); :}
    ;

extend type_declaration ::=
	COMMA_DECL IDENTIFIER:a
	    {: RESULT = (ClassDecl) parser.subst.get(a.getIdentifier()); :}
    ;

extend class_member_declaration ::=
	COMMA_MEMB IDENTIFIER:a
	    {: ClassMember m = (ClassMember) parser.subst.get(a.getIdentifier());
	       List l = new ArrayList(1);
	       l.add(m);
	       RESULT = l; :}
    ;

extend interface_member_declarations ::=
        COMMA_LIST IDENTIFIER:a
	    {: List l = (List) parser.subst.get(a.getIdentifier());
	       RESULT = l; :}
    ;

extend class_body_declarations ::=
        COMMA_LIST IDENTIFIER:a
	    {: List l = (List) parser.subst.get(a.getIdentifier());
	       RESULT = l; :}
    ;

extend formal_parameter_list ::=
	COMMA_LIST IDENTIFIER:a
	    {: List l = (List) parser.subst.get(a.getIdentifier());
	       RESULT = l; :}
    ;

extend throws ::=
	COMMA_LIST IDENTIFIER:a
	    {: List l = (List) parser.subst.get(a.getIdentifier());
	       RESULT = l; :}
    ;

extend class_type_list ::=
	COMMA_LIST IDENTIFIER:a
	    {: List l = (List) parser.subst.get(a.getIdentifier());
	       RESULT = l; :}
    ;

extend argument_list ::=
	COMMA_LIST IDENTIFIER:a
	    {: List l = (List) parser.subst.get(a.getIdentifier());
	       RESULT = l; :}
    ;
