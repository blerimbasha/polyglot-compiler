This document describes the major changes made to the Polyglot framework
for version 2.0 and how to upgrade extensions written for Polyglot 1.3.

The pass scheduling code was rewritten for Polyglot 2.0.  The goal was
to simplify the disambiguation passes, reduce the need for barrier
passes, and clean up the invariants assumed by the passes.

As an example, the Jx extension to Polyglot 1.3 had the following
disambiguation passes:

        create packages
        barrier
        disambiguate packages
        barrier
        type builder
        barrier
        disambiguate supertypes
        add dummy fields
        barrier
        disambiguate member signatures
        remove dummy fields
        barrier
        disambiguate method bodies
        add members
        type check
        ...

The new schedule has the following passes:

        type builder
        barrier
        disambiguate
        type check
        ...

Not only is the scheduler shorter, but the compiler should use less
memory as well (I'm still doing performance tuning).

The changes to the scheduler are not backward compatible and some
porting effort is required.  Porting small extensions (e.g., PAO) takes
a few minutes.  Porting Coffer took a few hours.  Larger extensions
(e.g., Jif, Jx) may take a few days or a week.

Changes
-------

The new scheduler works by attempting to satisfy _goals_.
Examples of goals are:

Parsed(Job)
        - Satisfied if the job's source file has been parsed
MembersAdded(ClassType)
        - Satisfied if members have been added to the class's type object
SupertypesResolved(ClassType)
        - Satisfied if the class's supertypes have been disambiguated
SignaturesResolved(ClassType)
        - Satisfied if member signatures of the class have been disambiguated
VisitorGoal(Job, Visitor) -
        - Satisfied if visitor has been run over job's AST
CodeGenerated(Job)
        - Satisfied if code has been generated from the job's AST

A goal may be dependent on other goals.

Goals can be satisfied by running passes.  Most passes just run a
visitor over the AST.  If no errors are encountered when running a pass,
the pass is said to succeed.  Even if a pass succeeds, the goal may not
be satisfied because running the pass may have caused the goal to become
dependent upon another goal, which is not yet satisfied.  For example,
the disambiguation pass may resolve a class name to a particular class
C, but may not be able to lookup a member of that class because the C's
members have not yet been added to the type object for C.  In this case,
the disambiguation pass is rescheduled to run after the members have
been added.

There are two types of dependencies between goals: prerequisite and
concurrent dependencies.  If a goal has a prerequisite dependency, that
dependency must be satisfied before the goal is attempted.  The compiler
will throw an InternalCompilerError if there is a cycle of prerequisite
dependencies.  If a goal has a concurrent dependency, running a pass for
the dependency may help the dependent goal be satisfied.  Having a cycle
of concurrent dependencies may or may not cause the compiler to go into
an infinite loop.  This situation is detected at run time and the
compiler aborts.

Concurrent dependencies should be avoided, if possible.  I want to get
rid of them because of the infinite loop problems.

Specific changes
----------------

Declarations (e.g., ClassDecl, MethodDecl, LocalDecl, Formal, etc)
should create corresponding TypeObjects exactly once, in the buildTypes
pass.  Class members should also be added during buildTypes.  The new
TypeObjects may be ambiguous (i.e., they may point to ambiguous
TypeObjects).  Later passes should imperatively update the TypeObjects
to be unambiguous.  Other node types (e.g., TypeNode, Call, Local, etc)
have references to the same TypeObjects created by the declarations.

Since TypeObjects used in declarations should be updated imperatively,
setter methods are needed for new TypeObjects added by an extension.
Only TypeObjects that are directly shared by more than one AST node
(e.g., Type, MethodInstance, FieldInstance, LocalInstance, etc) require
the setter methods.

Declaration nodes should also implement isDisambiguated().  This method
should return true if the TypeObject for the node has been completely
disambiguated.  It should not recurse on the node's children (a visitor
does that).

Non-declaration nodes should also implement isTypeChecked().  This
method should return true if the TypeObject for the node has been
resolved and completely disambiguated.  Node_c.isTypeChecked() calls
Node_c.isDisambiguated().

Pass.ID is no longer used.  It has been subsumed by Goal.

ExtensionInfo.passes() has been replaced by ExtensionInfo.compileGoalList().
To add a new pass, the old code would look like:

      public List passes(Job job) {
          List passes = super.passes(job);
          beforePass(passes, Pass.PRE_OUTPUT_ALL,
                     new VisitorPass(CAST_REWRITE, job,
                                     new PaoBoxer(job, ts, nf)));
          return passes;
      }

new code looks like:

      protected List compileGoalList(Job job) {
          List oldGoals = super.compileGoalList(job);
          ArrayList newGoals = new ArrayList(oldGoals.size() + 1);

          for (Iterator i = oldGoals.iterator(); i.hasNext(); ) {
              Goal g = (Goal) i.next();
              if (g instanceof Serialized) {
                  newGoals.add(new VisitorGoal(job,
                                               new PaoBoxer(job, ts, nf)));
              }
              newGoals.add(g);
          }

          return newGoals;
      }

Alternatively, you can override the caller of compileGoalList(),
getCompileGoal().

HaltingVisitor is deprecated; return a non-null Node from
NodeVisitor.override() to prune a visitor traversal.  InnerJob has been
removed and SourceJob has been merged into Job.  Job spawning has been
removed; just run visitors explicitly over the AST subtree.  Be sure to
set the new visitor's Context if needed.

If new class member types are added, extend LazyClassInitializer with
init methods.  Extend SchedulerClassInitializer to enforce scheduler
dependencies and DeserializedLazyClassInitializer also.  Override
TypeSystem_c.defaultClassInitializer() and
TypeSystem_c.deserializedClassInitializer().  Also override
ParsedClassType_c.numSignaturesResolved().

Lexer_c now takes a Source object, not the name of a source.
Adjust *.flex and ExtensionInfo accordingly.  It's probably easiest
just to copy over java.flex and reapply your changes.

    old ExtensionInfo:

      Lexer lexer = new Lexer_c(reader, source.name(), eq);

    new ExtensionInfo:

      Lexer lexer = new Lexer_c(reader, source, eq);

